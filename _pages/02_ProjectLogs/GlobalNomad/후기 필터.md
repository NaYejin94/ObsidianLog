
---

## 1. `ActivityDetailReview.tsx` - 필터 로직

### 코드

`const [filter, setFilter] = useState<'최신 순' | '별점 높은 순' | '별점 낮은 순'>('최신 순');  const sortedReviews = useMemo(() => {   if (!data?.reviews) return [];    const reviewsCopy = [...data.reviews];    if (filter === '별점 높은 순') {     return reviewsCopy.sort((a, b) => b.rating - a.rating);   }   if (filter === '별점 낮은 순') {     return reviewsCopy.sort((a, b) => a.rating - b.rating);   }   return reviewsCopy.sort((a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()); }, [data?.reviews, filter]);`

### 설명

- `filter`라는 **상태(state)**를 만들고, 기본값은 `'최신 순'`으로 설정.
    
    - `'최신 순'`, `'별점 높은 순'`, `'별점 낮은 순'` 중 하나를 가질 수 있어. (`useState` 제네릭에 이 타입 지정)
        
- `sortedReviews`는 `useMemo`를 써서 **`data.reviews` 배열을 정렬**하는 역할.
    
    - `useMemo`를 쓰는 이유는:
        
        - `data.reviews`나 `filter`가 변하지 않으면 **정렬을 다시 하지 않고** 캐시된 값을 쓴다.
            
        - 불필요한 리렌더링과 계산을 줄일 수 있음 → 성능 최적화.
            
- 정렬 방법:
    
    - `'별점 높은 순'`: `rating` 내림차순 (`b.rating - a.rating`)
        
    - `'별점 낮은 순'`: `rating` 오름차순 (`a.rating - b.rating`)
        
    - `'최신 순'`: `updatedAt` 날짜 내림차순 (새로운게 위로)
        

---

## 2. `ReviewHeader.tsx` - 필터 드롭다운

### 코드

`<DropdownSelect   onSelect={(value: string) => {     if (value === '최신 순' || value === '별점 높은 순' || value === '별점 낮은 순') {       setFilter(value);     }   }}   selected={filter}   options={['별점 높은 순', '별점 낮은 순', '최신 순']}   placeholder="필터"   icon={<Image src="/ic_arrow.svg" alt="필터 아이콘" width={22} height={22} />} />`

### 설명

- `DropdownSelect`는 드롭다운 컴포넌트. 필터를 고르는 UI.
    
- `onSelect`에서 드롭다운에서 선택한 `value`를 받아서:
    
    - `'최신 순'`, `'별점 높은 순'`, `'별점 낮은 순'` 중 하나면 `setFilter`를 호출해서 **필터 상태를 업데이트**.
        - `DropdownSelect`는 기본적으로 `string` 타입을 받아오는데, 우리가 받는 필터 값은 **정해진 문자열**(`'최신 순' | '별점 높은 순' | '별점 낮은 순'`) 중 하나여야 하니까 **type-safe**하게 막음.
            
- `selected={filter}`로 현재 선택된 필터를 표시해주고 있음.
    

---

## 3. `ReviewList.tsx` - 별점 렌더링 (리뷰 리스트)


``<div className="flex gap-1">   {Array(review.rating)     .fill(0)     .map((_, idx) => (       <Image key={`full-${idx}`} src="/ic_star_on.svg" alt="full star" width={18} height={18} />     ))}   {Array(5 - review.rating)     .fill(0)     .map((_, idx) => (       <Image key={`empty-${idx}`} src="/ic_star.svg" alt="empty star" width={18} height={18} />     ))} </div>``

### 설명

- `Array(review.rating)` → `review.rating`이 4면 `Array(4)`, 즉 길이 4짜리 배열 생성.
    
- `.fill(0)` → 이 배열을 **0으로 채움**. (`[0, 0, 0, 0]`)
    
- `.map((_, idx) => ( ... ))` → 배열의 **길이만큼 반복**해서 별 아이콘(`<Image>`)을 렌더링.
    
    - **배열 길이만큼 반복 렌더링**하려면 이 방식이 필요.
        
    - 그냥 `Array(4).map()` 하면 배열이 비어 있어서 동작 안 함 → `.fill(0)`으로 채워줘야 `.map()`이 작동.
        
- `full star`는 `review.rating` 갯수만큼,
    
- `empty star`는 `5 - review.rating` 갯수만큼 그려서 항상 5개 별을 채움.
    

---

## 📚 **정리**

|파일명|코드|설명|
|---|---|---|
|`ActivityDetailReview.tsx`|`useState`, `useMemo`로 정렬된 리뷰 만들기|리뷰를 필터 기준으로 정렬 (최신순, 별점순)|
|`ReviewHeader.tsx`|`DropdownSelect`로 필터 선택|필터 선택하면 `setFilter`로 상태 업데이트|
|`ReviewList.tsx`|`Array().fill(0).map()` 별 렌더링|별점 수 만큼 별 채우기, 항상 5개 표시|

---

**✅ 요지는**:

- **useState**로 현재 필터 저장하고
    
- **useMemo**로 필터 바뀔 때마다 정렬된 리뷰 계산하고
    
- **DropdownSelect**로 필터 선택
    
- **Array().fill(0).map()** 패턴은 "정해진 숫자만큼 렌더링"할 때 쓰는 가장 간단한 방법