# 📸 스냅샷으로서의 State

<aside>

💡 **React의 state는 단순한 변수처럼 보이지만**, 실제로는 **렌더링 시점의 스냅샷** 으로 동작한다. 렌더링이 실행되는 순간, 모든 state, props, 이벤트 핸들러는 그 시점 기준으로 "고정"된다.

</aside>

## ✅ State를 설정하면 렌더링이 동작한다

```jsx
import { useState } from 'react';

export default function Form() {
  const [isSent, setIsSent] = useState(false);
  const [message, setMessage] = useState('Hi!');
  
  if (isSent) {
    return <h1>Your message is on its way!</h1>
  }
  
  return (
    <form onSubmit={(e) => {
      e.preventDefault();
      setIsSent(true);
      sendMessage(message);
    }}>
      <textarea
        placeholder="Message"
        value={message}
        onChange={e => setMessage(e.target.value)}
      />
      <button type="submit">Send</button>
    </form>
  );
}

function sendMessage(message) {
  // ...
}
```

- 결과화면
    
    ![image.png](attachment:d694b9cb-dfee-45f8-821e-42792e3f2e99:image.png)
    
    ![image.png](attachment:d0834d0b-37b3-4848-8775-a35857900381:image.png)
    

### 🔄 실행 흐름

1. `onSubmit` 이벤트 핸들러 실행
2. `setIsSent(true)` → 새로운 렌더링이 큐에 들어감
3. React는 변경된 state에 따라 컴포넌트를 다시 렌더링

## 🧊 렌더링은 그 시점의 “스냅샷”을 찍는다

<aside>

📝 컴포넌트가 **렌더링된다는 것 = 함수가 호출되어 JSX를 반환하는 것**

JSX는 마치 사진처럼, **렌더링 당시의 상태를 고정**한 UI 구조이다.

</aside>

![image.png](attachment:fbb32407-51ce-4828-b4d3-090cbf5a725d:image.png)

📌 컴포넌트는 해당 렌더링의 state 값을 사용해 계산된 새로운 props 세트와 이벤트 핸들러가 포함된 UI의 스냅샷을 JSX에 반환한다!

![image.png](attachment:4e57fa71-0a46-422c-b704-e78d0d97e2af:image.png)

## 💟 상태는 고정된 값

```jsx
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button onClick={() => {
        setNumber(number + 1); //setNumber(0+1);
        setNumber(number + 1); //setNumber(0+1);
        setNumber(number + 1); //setNumber(0+1);
      }}>+3</button>
    </>
  )
}
```

### 🔍 결과는 왜 `+3`이 아닌 `+1`일까?

- `setNumber(number + 1)`은 **모두 같은 0을 기반**으로 하고 있음 → 결국 1 한 번만 적용됨
    
- 이유는?
    
    👉 이 렌더링에서의 `number`는 0으로 고정된 스냅샷이기 때문이다
    

## 🕐 타이머 예제

```jsx
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button onClick={() => {
        setNumber(number + 5);
        setTimeout(() => {
          alert(number); //0이 출력이 된다.
        }, 3000);
      }}>+5</button>
    </>
  )
}
```

<aside>

💡 State 변수의 값은 이벤트 핸들러의 코드가 비동기적이더라도 렌더링 내에서 절대 변경되지 않는다. 이 값은 컴포넌트를 호출해 React가 UI의 `“스냅샷을 찍을”`때 `“고정”`된 값이다. React는 렌더링의 이벤트 핸들러 내에서 state값을 `“고정”`으로 유지한다.

</aside>

## 🔥 그렇다면, 렌더링 하기 전에 최신 state를 읽고 싶다면 어떻게 해야할까? → 업데이터 함수를 사용하자 !

---

# 🧠 State 업데이트 큐

## ✅ React의 Batching 이란?

<aside>

**Batching**은 여러 개의 state 업데이트를 하나의 렌더링으로 묶어 처리함으로써 **렌더링 성능을 최적화**하고, **UI의 일관성**을 유지하는 React의 전략이다.

</aside>

## 💟 다음 렌더링 전에 동일한 state 변수를 여러 번 업데이트하기

```jsx
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button onClick={() => {
        setNumber(n => n + 1); //업데이터 함수라고 부름.
        setNumber(n => n + 1); //n=> n+1 함수를 큐에 추가한다.
        setNumber(n => n + 1);
      }}>+3</button>
    </>
  )
}
```

### 🧭 동작 방식

1. 각 `setNumber(n => n + 1)`는 **업데이터 함수**로 큐에 추가된다.
2. React는 렌더링 직전에 **이 함수들을 순차적으로 실행**하여 최종 값을 계산한다.
3. 하나의 렌더링으로 세 번의 업데이트가 적용되어 3이 출력된다.

📌 **업데이터 함수는 이전 state를 기반으로 새로운 값을 계산**하므로 안전하게 여러 번 호출 가능!

## ⚠️ state를 교체한 후 업데이트를 하면?

```jsx
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button onClick={() => {
        setNumber(number + 5);
        setNumber(n => n + 1);
      }}>Increase the number</button>
    </>
  )
}
```

1. 고정된 값인 5 자체를 직접 큐에 추가한다.
2. 두 번째 줄은 그 값을 기반으로 +1
3. 따라서 최종 결과는 6

💡 **업데이터 함수는 순차적으로 실행되며**, 앞선 변경을 반영할 수 있다.

![image.png](attachment:3f9b84da-7b70-4bb2-87c6-7a1e6916268c:image.png)

## 🧨 업데이트 후 state를 바꾸면?

```jsx
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button onClick={() => {
        setNumber(number + 5); // -> 5
        setNumber(n => n + 1); // -> 6 
        setNumber(42); // -> 42
      }}>Increase the number</button>
    </>
  )
}
```

<aside>

`setState(42)`은 지금 렌더링의 state 값으로 고정되며, 큐 안의 함수들을 덮어쓸 수 있다. 업데이터 함수는 순수 함수여야 한다.

</aside>

## 📌 요약

- 렌더링 시 state는 고정값
- 상태 업데이트는 이벤트 핸들러 종료 후 반영 → Batching
- 여러 업데이트 시, 업데이터 함수 사용으로 순차적 처리 가능

---

# 🔍 객체 state 업데이트하기

<aside>

‼ state는 객체를 포함한 모든 종류의 자바스크립트 값을 가질 수 있다. 하지만 react state가 가진 객체를 직접 변경해서는 안되고, 객체를 업데이트 하고 싶을 때는 복사본을 만들어 사용하자.

</aside>

## 📍 State를 읽기 전용인 것처럼 다루자

```jsx
import { useState } from 'react';

export default function MovingDot() {
  const [position, setPosition] = useState({
    x: 0,
    y: 0
  });
  return (
    <div
    
  /*  onPointerMove={e => {
  position.x = e.clientX;  // ❌ 직접 변경
  position.y = e.clientY; //state 객체인 position을 직접 수정. 리액트는 state 설정 함수가 없으면 객체가 변경되었는지 알 수 없음.
}} */

      onPointerMove={e => {
        setPosition({
          x: e.clientX,
          y: e.clientY
        });
      }}
    </div>
  )
}
```

> 변경은 이미 state에 존재하는 객체를 변경할 때만 문제가 된다. 방금 만든 객체를 수정하는 것은 아직 다른 코드가 해당 객체를 참조하지 않기 때문에 괜찮다. 이것을 지역 변경 (local mutation) 이라고 한다.

## 🧩 스프레드 연산자로 객체 복사하기

```jsx
import { useState } from 'react';

export default function Form() {
  const [person, setPerson] = useState({
    firstName: 'Barbara',
    lastName: 'Hepworth',
  });

  function handleChange(e) {
    setPerson({
      ...person, //기존의 person 객체를 복사
      [e.target.name]: e.target.value //input name 값을 새로운 값으로 업데이트
    });
  }

  return (
    <>
      <label>
        First name:
        <input
          name="firstName"
          value={person.firstName}
          onChange={handleChange}
        />
      </label>
      <p>
        {person.firstName}{' '}
      </p>
    </>
  );
}

```

- `...person` → 기존 person 객체 복사
- `[name]` 키만 새로운 값으로 교체
- 원본 객체는 유지되므로 불변성 보장

## 🧱 중첩된 객체 갱신하기

```jsx
import { useState } from 'react';

export default function Form() {
  const [person, setPerson] = useState({
    name: 'Niki de Saint Phalle',
    artwork: {
      title: 'Blue Nana',
      city: 'Hamburg',
      image: '<https://i.imgur.com/Sd1AgUOm.jpg>',
    }
  });

  function handleTitleChange(e) {
    setPerson({
      ...person,
      artwork: {
        ...person.artwork,
        title: e.target.value
      }
    });
  }

  return (
    <>
      <label>
        Title:
        <input
          value={person.artwork.title}
          onChange={handleTitleChange}
        />
      </label>
      <p>
        <i>{person.artwork.title}</i>
        {' by '}
        {person.name}
    </>
  );
}

```

## 🧈 Immer로 간결한 갱신 로직 작성하기

> state가 깊이 중첩되어 있다면 평탄화를 고려해보자. 만약 state를 바꾸고 싶지 않다면, immer을 이용하면 더 간편하게 중첩 전개를 할 수 있다.

```jsx
import { useImmer } from 'use-immer';

export default function Form() {
  const [person, updatePerson] = useImmer({
    name: 'Niki de Saint Phalle',
    artwork: {
      title: 'Blue Nana',
      city: 'Hamburg',
      image: '<https://i.imgur.com/Sd1AgUOm.jpg>',
    }
  });

  function handleTitleChange(e) {
    updatePerson(draft => {//person 상태의 복사본
      draft.artwork.title = e.target.value;
    }); //직접 수정 코드를 쓸 수 있으면서도 불변성은 유지된다.
  }

  return (
    <>
      <label>
        Title:
        <input
          value={person.artwork.title}
          onChange={handleTitleChange}
        />
      </label>
      <p>
        <i>{person.artwork.title}</i>
        {' by '}
        {person.name}
    </>
  );
}

```

## 🤔 왜 react에서 state 변경은 권장되지 않을까?

- **디버깅이 쉬워짐**
    - state를 직접 변경하지 않으면, console 로그가 과거 상태를 정확히 보여줘서 추적이 쉬움
- **성능 최적화에 유리**
    - React는 `prev === next`로 변경 여부를 판단 → 불변성을 유지하면 비교가 빠르고 정확함
- **React의 새로운 기능과 호환성 유지**
    - 예: 타임머신 디버깅, 스냅샷, 동기화 기능은 state가 바뀌지 않는 전제를 기반으로 동작함
- **확장성 있는 기능 구현 가능**
    - 예: 상태 복원/되돌리기/변화 추적 등 기능이 쉬워짐 (과거 state를 그대로 저장 가능)
- **간단한 내부 구현**
    - React는 state 객체를 프록시로 감싸거나 추적하지 않음 → 단순하면서도 강력한 구조 가능

---

# 🧱 배열 State 업데이트하기

<aside>

배열은 JS에서는 변경이 가능하지만, state로 저장할 때는 변경할 수 없도록 처리해야 한다. 객체와 마찬가지로 새 배열을 생성 ( 혹은 복사본을 생성) 한 뒤, state로 두어 업데이트한다.

</aside>

## 변경하지 않고 배열 업데이트하기

![image.png](attachment:1b86eb78-bca3-4465-94e9-63346edcd745:image.png)

## ➕ 배열에 항목 추가하기

```jsx
import { useState } from 'react';

let nextId = 0;

export default function List() {
  const [name, setName] = useState('');
  const [artists, setArtists] = useState([]);

  return (
    <>
     /* <button onClick={() => { //react는 state가 변경되었는지 "참조 비교"로 확인하는데, 같은 참조가 전달되면 리렌더링 X
        artists.push({
          id: nextId++,
          name: name,
        });
      }}>Add</button> */
      
       <button onClick={() => {
        setArtists([
          ...artists,
          { id: nextId++, name: name }
        ]);
      }}>Add</button>
      
      <ul>
        {artists.map(artist => (
          <li key={artist.id}>{artist.name}</li>
        ))}
      </ul>
    </>
  );
}

```

- `...artists`로 기존 배열을 복사한다.
    
- 새 항목을 마지막에 추가
    
    → 새로운 배열이 생성되므로 상태가 안전하게 업데이트된다.
    

❌ `artists.push(...)`는 원본 배열을 직접 변경하므로 리렌더링이 발생하지 않을 수 있다.

## ➖ 배열에서 항목 제거하기

```jsx
import { useState } from 'react';

let initialArtists = [
  { id: 0, name: 'Marta Colvin Andrade' },
  { id: 1, name: 'Lamidi Olonade Fakeye'},
  { id: 2, name: 'Louise Nevelson'},
];

export default function List() {
  const [artists, setArtists] = useState(
    initialArtists
  );

  return (
    <>
      <h1>Inspiring sculptors:</h1>
      <ul>
        {artists.map(artist => (
          <li key={artist.id}>
            {artist.name}{' '}
            <button onClick={() => {
              setArtists(
                artists.filter(a =>
                  a.id !== artist.id
                )
              );
            }}>
              Delete
            </button>
          </li>
        ))}
      </ul>
    </>
  );
}

```

- `filter()`는 조건을 만족하는 항목만 골라 **새 배열**을 반환한다.
- 삭제할 항목을 제외한 배열이 생성되어 state가 불변성 있게 바뀐다.

## 🔄 배열 변환하기

```jsx
import { useState } from 'react';

let initialShapes = [
  { id: 0, type: 'circle', x: 50, y: 100 },
  { id: 1, type: 'square', x: 150, y: 100 },
  { id: 2, type: 'circle', x: 250, y: 100 },
];

export default function ShapeEditor() {
  const [shapes, setShapes] = useState(
    initialShapes
  );

  function handleClick() {
    const nextShapes = shapes.map(shape => {
      if (shape.type === 'square') {
        // 변경시키지 않고 반환합니다.
        return shape;
      } else {
        // 50px 아래로 이동한 새로운 원을 반환합니다.
        return {
          ...shape,
          y: shape.y + 50,
        };
      }
    });
    // 새로운 배열로 리렌더링합니다.
    setShapes(nextShapes);
  }
}

```

- `map()`은 배열의 각 항목을 순회하며 수정할 항목만 바꾸고 나머지는 그대로 유지
- 수정된 새 객체로 교체 → 나머지는 이전 참조 그대로 사용 가능

## 🔁 배열 내 항목 교체하기

```jsx
import { useState } from 'react';

let initialCounters = [
  0, 0, 0
];

export default function CounterList() {
  const [counters, setCounters] = useState(
    initialCounters
  );

  function handleIncrementClick(index) {
    const nextCounters = counters.map((c, i) => {
      if (i === index) {
        // 클릭된 counter를 증가시킵니다.
        return c + 1;
      } else {
        // 변경되지 않은 나머지를 반환합니다.
        return c;
      }
    });
    setCounters(nextCounters);
  }
}

```

- 특정 인덱스만 값을 변경하고, 나머지는 그대로 유지
- 모든 항목을 새 배열로 만들어서 React가 변경을 감지할 수 있도록 함

## **🧩 배열에 항목 삽입하기**

```jsx
import { useState } from 'react';

let nextId = 3;
const initialArtists = [
  { id: 0, name: 'Marta Colvin Andrade' },
  { id: 1, name: 'Lamidi Olonade Fakeye'},
  { id: 2, name: 'Louise Nevelson'},
];

export default function List() {
  const [name, setName] = useState('');
  const [artists, setArtists] = useState(
    initialArtists
  );

  function handleClick() {
    const insertAt = 1; // 모든 인덱스가 될 수 있습니다.
    const nextArtists = [
      // 삽입 지점 이전 항목
      ...artists.slice(0, insertAt),
      // 새 항목
      { id: nextId++, name: name },
      // 삽입 지점 이후 항목
      ...artists.slice(insertAt)
    ];
    setArtists(nextArtists);
    setName('');
  }
}

```

- `slice()`는 배열을 잘라서 복사
- **삽입 지점 전/후**로 잘라낸 배열에 새 항목을 끼워 넣음
- 새 배열을 만들어 상태로 설정 → 불변성 유지 ✅

## **🔃 배열에 기타 변경 적용하기**

```jsx
import { useState } from 'react';

const initialList = [
  { id: 0, title: 'Big Bellies' },
  { id: 1, title: 'Lunar Landscape' },
  { id: 2, title: 'Terracotta Army' },
];

export default function List() {
  const [list, setList] = useState(initialList);

  function handleClick() {
    const nextList = [...list];
    nextList.reverse();
    setList(nextList);
    //nextList[0]="something"
  }
  
  /* const nextList = [...list];
nextList[0].seen = true; // 문제: list[0]을 변경시킵니다.
setList(nextList);*/

  return (
    <>
      <button onClick={handleClick}>
        Reverse
      </button>
      <ul>
        {list.map(artwork => (
          <li key={artwork.id}>{artwork.title}</li>
        ))}
      </ul>
    </>
  );
}

```

- `reverse()`, `sort()` 등은 **원본을 변경**하는 메서드
- 반드시 `[...배열]`로 복사한 후에 적용해야 안전하게 리렌더링됨

## **🧠 배열 내부의 객체 업데이트하기**

> 배열 안의 객체의 특정 필드만 업데이트하고 그 외에는 건드리지 않는 방식으로 상태를 안전하게 변경한다.

```jsx
import { useState } from 'react';

let nextId = 3;
const initialList = [
  { id: 0, title: 'Big Bellies', seen: false },
  { id: 1, title: 'Lunar Landscape', seen: false },
  { id: 2, title: 'Terracotta Army', seen: true },
];

export default function BucketList() {
  const [myList, setMyList] = useState(initialList);
  const [yourList, setYourList] = useState(
    initialList
  );
  
  
/*  function handleToggleMyList(artworkId, nextSeen) {
    const myNextList = [...myList];
    const artwork = myNextList.find(
      a => a.id === artworkId
    );
    artwork.seen = nextSeen;
    setMyList(myNextList);
  } */

  function handleToggleMyList(artworkId, nextSeen) {
    setMyList(myList.map(artwork => {
      if (artwork.id === artworkId) {
        // 변경된 *새* 객체를 만들어 반환합니다.
        return { ...artwork, seen: nextSeen };
      } else {
        // 변경시키지 않고 반환합니다.
        return artwork;
      }
    }));
  }

}

```

- `map()`으로 원하는 객체만 골라 복사 → 수정
- 나머지 객체는 그대로 유지
- ✅ 상태 불변성을 지키면서 **부분만 업데이트 가능**

## **🧈 Immer로 간결한 업데이트 로직 작성하기**

```jsx
import { useState } from 'react';
import { useImmer } from 'use-immer';

let nextId = 3;
const initialList = [
  { id: 0, title: 'Big Bellies', seen: false },
  { id: 1, title: 'Lunar Landscape', seen: false },
  { id: 2, title: 'Terracotta Army', seen: true },
];

export default function BucketList() {
  const [myList, updateMyList] = useImmer(
    initialList
  );
  const [yourArtworks, updateYourList] = useImmer(
    initialList
  );

  function handleToggleMyList(id, nextSeen) {
    updateMyList(draft => {
      const artwork = draft.find(a =>
        a.id === id
      );
      artwork.seen = nextSeen;
    });
  }

  function handleToggleYourList(artworkId, nextSeen) {
    updateYourList(draft => {
      const artwork = draft.find(a =>
        a.id === artworkId
      );
      artwork.seen = nextSeen;
    });
  }
}
```

### ✅ Immer의 장점

- **불변성을 유지하면서도** 마치 직접 수정하듯 코딩할 수 있음
- 중첩된 객체를 다룰 때 매우 유리
- `draft`는 실제로는 복사본이기 때문에 React의 상태 변경 감지에 문제 없음

## 🔥 결론

<aside>

💡 배열 state를 다룰 때는 항상 **불변성을 유지하며 새 배열을 만들어야** React가 상태 변화를 정확히 감지하고 리렌더링할 수 있습니다

</aside>