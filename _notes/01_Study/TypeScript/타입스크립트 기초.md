자바스크립트만으로도 웹 애플리케이션을 개발할 수 있지만, 프로젝트 규모가 커지면서

**타입 안정성**, **코드 가독성 및 유지보수성**에 대한 요구가 커지고 있습니다.

이를 해결하기 위해 타입스크립트(TypeScript)가 등장하였습니다.

## 타입스크립트란?

타입스크립트는 자바스크립트에 정적 타입 시스템(Static Type System)을 추가한 언어입니다.

즉, 자바스크립트의 문법과 기능을 모두 포괄하면서, 컴파일 단계에서 미리 타입을 확인하고 오류를 방지할 수 있도록 지원합니다.

### 정적 타입시스템

- **정적 타입시스템**이란, 프로그램이 실행되기 전에(컴파일 단계) 모든 변수와 표현식의 타입을 검사하고 확정하는 방식을 말합니다.
- 이를 통해 런타임(실행 시점)에 발생할 수 있는 오류를 사전에 예방하고, 더 안정적인 코드를 작성할 수 있습니다.

### 정적 타입시스템의 장점

1. **오류를 사전에 발견**
    
    코드가 실제로 실행되기 전, 컴파일 단계에서 타입 불일치 등 여러 오류를 미리 확인할 수 있습니다.
    
2. **유지보수성 향상**
    
    타입이 명시적으로 드러나기 때문에 코드의 의도를 파악하기 쉬워지고, 협업 시에도 실수를 줄일 수 있습니다.
    
3. **개발 생산성 향상**
    
    IDE(통합 개발 환경)에서 제공되는 자동 완성, 코드 탐색, 리팩토링 기능이 더욱 강력해집니다.
    

## 자바스크립트에서 타입스크립트로

### 왜 처음부터 타입스크립트로 만들지 않았는가?

자바스크립트는 브라우저에서 동작하기 위해 **짧은 시간(약 10일)** 동안 설계되었습니다.

자유도와 유연함을 최우선으로 했고, 모든 구조가 **동적**(Dynamic)으로 동작합니다.

이러한 특징은 초기 웹 페이지에서 간단한 동작을 제어하기에는 좋지만, 규모가 커질수록 **정적 타이핑**의 필요성이 대두되었습니다.

### 자바스크립트와 타입스크립트는 어떤 관계인가?

- 타입스크립트 코드는 결국 **100% 자바스크립트 코드로 컴파일**됩니다.
- 즉, 타입스크립트는 자바스크립트에 **‘정적 타입 검사’**라는 한 가지 기능이 덧붙여진 확장판이라고 볼 수 있습니다.
- 다음 예시 두 코드를 비교해보면, 타입 정의 부분을 제외하면 실제 동작 자체는 동일합니다.

- App.jsx
    
    ```TypeScript
    // App.jsx (자바스크립트/JSX)
    import React from 'react';
    
    const App = () => {
      return (
        <div>
          <h1>Hello, World!</h1>
          <p>This is a simple React component.</p>
        </div>
      );
    };
    
    export default App;
    ```
    
- App.tsx
    
    ```TypeScript
    // App.tsx (타입스크립트/TSX)
    import React from 'react';
    
    const App: React.FC = () => {
      return (
        <div>
          <h1>Hello, World!</h1>
          <p>This is a simple React component.</p>
        </div>
      );
    };
    
    export default App;
    ```
    

- `App.tsx`에서 눈에 띄는 차이점은 `React.FC`(React Function Component)와 같은 **타입 선언**이 있을 뿐입니다.
- 이런 사소한 타입 선언만으로도 컴파일 시점에 타입 오류를 검출할 수 있고, 코드 자동 완성 등의 생산성을 높일 수 있습니다.

## 타입스크립트 프로젝트 시작하기

```Shell
npm create vite@latest
```

이 명령어로 프로젝트를 생성한 뒤, 폴더 구조 내에 `*.tsx` 파일들이 자동으로 설정되어 있으면

이미 타입스크립트 설정이 적용되어 있는 상태입니다.

## 타입 선언 (Type Declaration)

타입스크립트는 타입을 어떻게 선언할까요?

기존 자바스크립트에서는 `let`, `const` 같은 키워드로 변수를 선언했습니다.

타입스크립트 역시 같은 방식을 사용하되, **타입을 명시**하는 부분이 추가됩니다.

### 빌트인 타입(Primitive Types)

타입스크립트는 JavaScript가 기본 제공하는 여러 원시 타입(Primitive Types)을 지원합니다. 대표적으로:

- `number`
- `string`
- `boolean`
- `object`
- `undefined`
- `null`
- `any`
- `void`

이러한 타입들은 자바스크립트의 동작과 유사합니다. 여기에 **타입 선언(Type Annotation)** 을 통해

명시적으로 변수에 타입을 부여할 수 있습니다.

### 커스텀 타입: Type Alias와 Interface

원시 타입 외에도, 개발자가 직접 정의한 **커스텀 타입**이 필요할 때가 많습니다.

이를 위해 **타입 별칭(Type Alias)** 과 **인터페이스(Interface)** 를 사용할 수 있습니다.

```TypeScript
// 1) 타입 별칭(Type Alias)
type ExampleType = string;
type Person = {
  name: string;
  age: number;
};

// 2) 인터페이스(Interface)
interface ExampleInterface {
  name: string;
  age: number;
  favoriteDrink: "water" | "juice";
}
```

### 타입 별칭(Type Alias) vs 인터페이스(Interface)

- **공통점**:
    
    둘 다 객체, 함수 등 복합적 구조에 대한 타입을 정의할 수 있습니다.
    
- **차이점**:
    1. **확장성(Extensibility)**
        - 인터페이스는 여러 번 선언이 가능하며, 같은 이름으로 추가 속성을 정의하거나 상속(extends)할 수 있습니다.
        - 타입 별칭은 한 번 선언되면 재선언이 불가능합니다.
    2. **복잡한 타입 표현**
        - 타입 별칭은 유니온(Union) 타입, 교차(Intersection) 타입 등 복합적인 타입 표현에 보다 적합합니다.
        - 인터페이스는 기본적으로 객체의 형태를 정의하는 데 최적화되어 있습니다.
    3. **클래스 호환성**
        - 클래스는 인터페이스를 `implements` 키워드로 손쉽게 구현할 수 있습니다.
        - 타입 별칭도 사용 가능하지만, 인터페이스가 조금 더 직관적입니다.

> 결론적으로, 확장성과 클래스 구현 측면을 중요하게 생각한다면 인터페이스,
> 
> 유니온 타입 등 복잡한 타입 구성이 필요하다면 **타입 별칭**을 선택하는 경우가 많습니다.

## 타입 추론(Type Inference)과 어노테이션(Annotation)

### 타입 추론

타입스크립트는 작성된 코드를 기반으로 **자동으로 타입을 추론**합니다. 예를 들어:

```TypeScript
let num = 10;       // number로 추론
let str = "Hello";  // string으로 추론
let bool = true;    // boolean으로 추론
```

함수의 반환값 역시 코드에서 반환되는 타입을 추론해냅니다.

```TypeScript
function add(a: number, b: number) {
  return a + b; // 반환값을 number로 추론
}
const result = add(5, 3); // result는 number로 추론
```

### 컨텍스트 기반 추론(Contextual Typing)

콜백 함수나 배열 메서드(`map`, `forEach`) 등을 사용할 때, 인자의 타입을 문맥적으로 유추합니다.

```TypeScript
let numbers = [1, 2, 3, 4, 5];
numbers.forEach((num) => {
  console.log(num); // num을 number로 추론
});
```

### 타입 어노테이션(Annotation)

그러나 타입스크립트의 추론은 ‘완벽’하지 않을 때가 있으며, 더욱 명확한 타입 선언을 위해 **어노테이션**이 필요합니다.

```TypeScript
function subtract(a: number, b: number) {
  a - b; // 이 상태로는 반환값을 추론하지 못해 void로 인식
}

const subtractExplicit = (a: number, b: number): number => {
  return a - b;
};
```

즉, 타입스크립트를 효율적으로 사용하기 위해서는 **자동 추론이 가능하더라도, 핵심 로직에는 명시적인 타입 어노테이션을 권장**하는 편입니다.

## 구조적 타입(Structural Typing)

타입스크립트는 **구조적 타입 시스템**을 사용합니다. 두 개의 객체가 같은 **구조**와 **프로퍼티**를 지닌다면, 이름이 달라도 동일한 타입으로 간주합니다.

```TypeScript
interface Person {
  name: string;
  age: number;
}

let p1: Person = { name: "Alice", age: 25 };
let p2 = { name: "Bob", age: 30 };

p1 = p2; // 구조가 동일하므로 할당 가능
```

> 오리처럼 걷고, 오리처럼 소리 내면 오리로 간주한다는 ‘덕 타이핑(Duck Typing)’의 개념과 유사합니다.

## 제네릭(Generic)

제네릭은 **타입에 대한 파라미터**를 명시할 수 있도록 하는 기능입니다.

함수나 클래스, 인터페이스 등에서 **타입을 인자로 받아** 보다 유연하고 재사용성 높은 구조를 설계할 수 있습니다.

```TypeScript
// 제네릭 함수 예시
function getItem<T>(items: T[], index: number): T {
  return items[index];
}

const numbers = [1, 2, 3];
const result = getItem<number>(numbers, 0); // 숫자 배열에서 가져오므로 number로 추론
```

또 다른 예로, 객체의 특정 키를 안전하게 접근할 수 있도록 제네릭을 사용할 수도 있습니다.

```TypeScript
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const person = { name: "Charlie", age: 29 };
const personName = getProperty(person, "name"); // 안전하게 string 타입 추론
```

> 제네릭은 코드 재사용성과 타입 안정성을 동시에 확보하는 강력한 기능으로,
> 
> 다소 익숙해지는 데 시간이 필요하지만 숙달되면 매우 유용합니다.

자주쓰는 유틸리티 타입

1. Pick
2. Omit
3. ReturnType
    1. Awaited
    2. Parameters
4. Partial