[](https://jbee.io/articles/react/%EC%A0%84%EC%97%AD%20%EC%83%81%ED%83%9C%20%EA%B4%80%EB%A6%AC%EC%97%90%20%EB%8C%80%ED%95%9C%20%EB%8B%A8%EC%83%81%20\(stale-while-revalidate\))[https://jbee.io/articles/react/전역](https://jbee.io/articles/react/%EC%A0%84%EC%97%AD) 상태 관리에 대한 단상 (stale-while-revalidate) - 전역 상태 관리에 대한 단상

## 전역 상태는 뭘까?

- 전역 상태란? 애플리케이션을 구성하고 있는 코드 어디에서든지 접근이 가능하며, 변화에 따라 렌더링에 영향을 줘야하는 값

## 프론트엔드 애플리케이션의 상태

- 외부에서 주입되는 동적인 데이터 (ex. Server Response)
- 애플리케이션 UI 상태 (ex. isOpen)

# 외부에서 주입되는 동적인 데이터 (ex. Server Response)

## 만약 여러 컴포넌트에서 하나의 상태에 접근해야 한다면?

- 어느 정도는 Props drilliing으로 해결할 수는 있겠지만, 상태를 억지로 lifting해야 하는 문제가 생길 수 있다.
- 이럴 때 전역 상태 관리 라이브러리를 사용하게 되면 props를 전달하거나 state를 lifting 할 필요가 없고 원하는 값을 전역 저장소에서 접근해서 가져오면 된다.

## Redux를 서버 상태 저장소로 사용하게 될 때 발생할 수 있는 문제에 대해서

### 1. 필요로 하는 값은 redux에 존재한다는 가정

- 컴포넌트가 redux에 접근해서 상태를 가져오려면 `dispatch(fetch)` 가 선행되어 반드시 실행되어야 한다. 그래야 필요로 하는 값의 초기값이 아닌 값을 가져올 수 있을 테니까

> 근데 이 이야기는 불필요한 네트워크 비용을 줄이기 위해서 필요한 시점에 데이터를 불러오는 것이 맞다는 의견과 다른 해결책을 의미한다.

### 2. 특정 시점에 capture된 데이터

- redux에 저장된 데이터는 `dispatch(fetch)` 가 실행된 시점에 capture된 데이터를 의미한다. 호출한 시점에서는 동일한 내용의 데이터지만, 다시 서버 API를 호출하기 전에 어떤 변화가 있을지 알 수 없기 때문에 두 데이터가 동일하다는 것을 보장할 수 없게 된다.

## 문제 해결하기

### Caching in memory

- CACHE 라는 단순한 object에 서버의 응답을 캐싱되 둠으로 인해서 캐싱된 값이 있다면 그 값을 반환하고 없다면 서버로부터 데이터를 fetch 해온 값을 반환

> 중복해서 데이터를 받아오는 부분을 해결함

### stale-while-revalidate

- HTTP Header의 Cache-Control을 이용해서 정해진 시간동안 HTTP 요청의 반복된 발생을 감지해서 그대로 반환하거나, 재검증 절차를 통해서 값을 반환하도록 설계할 수 있다.

=> 위의 두 문제를 해결하여 등장한 라이브러리가 다음과 같다.

- react-query
- swr
- rtk-query

# UI state

대부분의 UI상태는 자연스럽게 컴포넌트 내에 위치하게 된다. 거의 대부분은 Redux에서 관리하지 않지만, Toast, Modal, Dialog 등 컴포넌트 트리를 벗어나 노출되는 컴포넌트들은 상태를 어디에선가 주입받는 형식으로 노출 여부가 결정된다.

## Context API

Modal과 같은 컴포넌트를 제어해야 하는 컴포넌트의 상단에서 ModalProvider로 Modal에 대한 제어와 정보를 주입할 수 있다.

### Context API로 전역 상태를 관리할 수 있지만, 필요없이 리렌더링을 유발시켜 성능에 이슈가 있다.

이러한 경우 react-redux와 비교해서 실제로 애플리케이션 전반의 성능에 영향을 미치고 있는 것은 맞다. 그런데 UI state와 같은 것을 전역 상태로 관리하는 게 적절할까?

## 다시 전역 상태

- 전역 상태란? 애플리케이션을 구성하고 있는 코드 어디에서든지 접근이 가능하며, `변화에 따라 렌더링에 영향을 줘야하는 값`

### 전역 상태에 어울리는 값

- 테마(Theme): 테마의 경우 모든 컴포넌트에 영향을 줘야 하고 컴포넌트들은 테마가 달라질 경우 다시 렌더링 되어야 하기 때문에
- 다국어 처리(i18n): 언어를 변경하게 되면 컴포넌트 전체적으로 다시 렌더링을 시켜야 하기에 전역으로 볼 수 있을 듯 하다.

### 필자가 생각하는 전역 상태

위의 2개 외에는 일반적으로 전역 상태에서 관리할 상태는 없다고 생각한다고 한다. 애플리케이션의 크기가 커지면 커질수록 전역에서 관리해야 하는 상태는 없어지고(전체 컴포넌트에 영향을 미칠 상태는 없기 때문에) 여러 컴포넌트가 상태를 공유해야 하는 경우, 상태를 공유해야 하는 컴포넌트를 Provider로 묶어줘서 해결할 수 있다.

그럼에도 불구하고, 필요한 상황도 충분히 존재할 수 있다.

- 컴포넌트 간 공유하는 상태가 굉장히 복잡하여 데이터를 정규화하여 관리가 필요하고
- 관리하고 있는 상태가 지속적으로 업데잍가 이우어져 성능 최적화가 필요하다면 Context API로 한계가 있을 수 있기 때문에 이 글에서 언급한 Redux나 Jotai같은 전역 상태관리 라이브러리가 좋은 대안이 될 수 있다고 생각한다.

## [Summary](https://jbee.io/articles/react/%EC%A0%84%EC%97%AD%20%EC%83%81%ED%83%9C%20%EA%B4%80%EB%A6%AC%EC%97%90%20%EB%8C%80%ED%95%9C%20%EB%8B%A8%EC%83%81%20%5C\(stale-while-revalidate%5C\)#summary)

이 글의 목적이었던 Redux라는 도구에 대한 회고를 정리하자면, 서버의 응답을 캐싱하기 위한 목적으로 Redux는 어울리지 않는다는 것이다. 그럼에도 불구하고 Redux가 필요한 상황이라면, 앞서 언급한 문제점들을 보완할 무언가들과 함께 사용해야 불행을 미리 피할 수 있다. (위에서 언급한 아예 다른 선택지를 택하는 방법도 있겠다.)

일반적으로 외부에서 주입되는 동적인 데이터는 캐싱에 기반하여 단일 원천인 서버 API를 바라보도록 하고, UI 상태들은 필요한 컴포넌트에서 가장 가까운 곳에 정의되어 있어야 한다. 재사용 가능함은 생산성에 큰 영향을 미친다. 애플리케이션에서 존재할 수 있는 상태를 최대한 고립시켜야 응집도가 높고 재사용성이 높은 hooks와 컴포넌트가 만들어진다고 생각한다.

[https://frontend-fundamentals.com/code/start.html](https://frontend-fundamentals.com/code/start.html) - 좋은 코드의 기준