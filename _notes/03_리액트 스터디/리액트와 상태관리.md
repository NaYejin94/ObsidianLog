## ✅ 상태 관리가 왜 필요할까?

<aside> 💡

상태: 어떠한 의미를 지닌 값이며 애플리케이션의 시나리오에 따라 지속적으로 변경될 수 있는 값(e.g., UI / URL / FORM / API 요청 등의 서버에서 가져온 값)

</aside>

시간이 지나면서 웹 서비스에서 다양한 기능들이 제공 되기 시작하고, 내부에서 관리해야 할 상태도 증가하게 되었다. 그에 따라 **이 상태를 효율적으로 관리할 수 있는 방법에 대한 심층적인 고민이 필요한 시점이 된 것.**

## ✅ Flux 패턴

리액트에서 자체적으로 제공해주는 전역 상태 관리 수단은 `Context API`가 있다(이는 정확히는 상태 관리가 아니라 상태 주입을 도와주는 역할이라고 합니다..!).

`Context API`는 16.3 버전에서, `useContext`는 16.8 버전에서 제공되었다. 그 전까진 리액트 환경에서 이름을 널리 알린 상태 관리 라이브러리는 없었다(16.3 버전은 2018년 6월에 출시 되었다고 합니다.).

그러던 중 2014년경 Flux 라이브러리를 소개 하게 된다. 위에서 언급한 것처럼 이 당시 웹에서 제공하는 서비스가 방대해지면서, 상태 또한 비례하게 되었는데 이 상태가 변화한 근간에 대한 추적이 어려웠다.

![image.png](attachment:ff03b612-8bf5-4934-920f-c637107930a8:image.png)

페이스북 팀은 원인을 양방향 데이터 바인딩으로 보았고, 이를 단방향 데이터 흐름으로 변경하자는 제안이 나왔다. 이것이 Flux 패턴의 시작이다.

![image.png](attachment:8f211f91-6025-45d0-a84b-3ba06d126a5c:image.png)

각 용어의 정의는 다음과 같다.

- 액션(action): 어떠한 작업을 처리할 액션과 그 **액션 발생 시 함께 포함시킬 데이터**를 의미한다.
- 디스패처(dispatcher): 액션을 스토어에 보내는 역할
- 스토어(store): **실제 상태에 따른 값과 상태를 변경할 수 있는 메서드**를 가지고 있다.
- 뷰(view): **리액트의 컴포넌트**에 해당하는 부분으로, 스토어에서 만들어진 데이터를 가져와 **화면에 렌더링** 하는 역할을 한다.

☑️ 단방향 데이터 흐름의 장단점

- 장점: 데이터 흐름은 모두 액션이라는 한 방향으로 줄어들기 때문에 **흐름을 추적하기 쉽고 코드를 이해하기가 수월하다.**
- 단점: 사용자의 입력에 따라 데이터를 갱신하고 화면을 어떻게 업데이트 해야 하는지도 코드로 작성해야 하므로 코드의 양이 많아지고 개발자도 수고로워진다.

리액트는 단방향 데이터 바인딩을 기반으로 한 라이브러리였기에 Flux 패턴과 굉장히 잘 맞았다.

## ✅ 리덕스(Redux)의 등장

리덕스도 최초에는 Flux 구조를 구현하기 위해 만들어진 라이브러리 중 하나였다. 특별한 점은 여기에 **Elm 아키텍처를 도입했다는 것이다**.

> **An Introduction to Elm Elm is a functional language that compiles to JavaScript.** ... 자바스크립트로 컴파일 되는 함수형 언어다. - elm 공식 문서 -

Elm에서 주목해야 할 키워드

- 모델(model): 애플리케이션의 상태
- 뷰(view): 모델을 표현하는 HTML
- 업데이트(update): 모델을 수정하는 방식

Elm은 Flux와 마찬가지로 데이터 흐름을 세 가지로 분류하고, 단방향으로 강제해 웹 애플리케이션의 상태를 안정적으로 관리하고자 노력했다.

리덕스는 하나의 상태 객체를 스토어에 저장해 두고, 객체를 업데이트 하는 작업을 디스패치해 업데이트를 수행한다. 이 작업은 `reducer` 함수로 발생 시킬 수 있는데, 이 함수의 실행은 **상태에 대해 완전히 새로운 복사본을 반환한 다음, 애플리케이션에 이 새롭게 만들어진 상태를 전파하게 된다.**

☑️ 리덕스의 장단점

- 장점: 하나의 글로벌 상태 객체로 하위 컴포넌트에 전파가 가능하기에 props drilling을 해결할 수 있고, 스토어가 필요한 컴포넌트라면 `connect`만 쓰면 바로 접근 가능하다.
- 단점: 하고자 하는 일에 비해 보일러 플레이트가 너무 많다.

## ✅ Context API와 useContext의 등장

16.3 버전에서 `Context API`가 출시 됐다. 이에 따라 props로 상태를 넘겨주지 않아도 원하는 곳에서 `Context Provider`가 주입 하는 상태를 사용할 수 있게 된 것이다.

그러나 Context API는 상태 관리가 아닌 **주입을 도와주는 기능**이며, **렌더링을 막아주는 기능 또한 존재하지 않으니 사용할 때 주의가 필요하다.**

16.8 버전에서는 함수 컴포넌트에 사용할 수 있는 다양한 훅 API가 추가됐다. 이에 따라 다른 상태 관리 방식이 등장하는데, 그것이 바로 `React Query`와 `SWR`이다.

![image.png](attachment:32ec6b1e-7340-4d12-903c-e889ba4501b7:image.png)

![image.png](attachment:e05a86d6-dfb9-4a9a-96ce-b6c697726dcd:image.png)

둘 다 외부에서 데이터를 불러오는 `fetch`를 관리하는 데 특화된 라이브러리지만, **API 호출에 대한 상태를 관리하고 있기 때문에 HTTP 요청에 특화된 상태 관리 라이브러리라 볼 수 있다.**

이처럼 특화된 기능에 초점을 둔 것과 다르게 좀 더 범용적으로 쓸 수 있는 상태 관리 라이브러리는 뭐가 있을까? 그것이 바로 `Recoil`, `Jotai`, `Zustand`, `Valtio` 등이다. **이들의 가장 큰 특징은 훅을 활용해 작은 크기의 상태를 효율적으로 관리 한다는 것이다. 그렇기에 기본적으로 16.8 버전 이상을 요구한다.**

## ✅ 리액트 훅으로 시작하는 상태 관리

가장 기본적인 방법: `useState` 와 `useReducer`

`useState` 의 등장으로 여러 컴포넌트에 걸쳐 손쉽게 상태를 관리할 수 있게 됐다. 커스텀 훅을 `useState` 로 제작해 코드를 격리하고, 어디서든 손쉽게 재사용 할 수 있게 만든다.

`useReducer` 또한 지역 상태를 관리할 수 있는 훅이다. (`useState` 를 `useReducer` 로 구현 했기에, `useState`로 상태 관리를 하는 것과 비슷하게 `useReducer`도 비슷한 동작을 한다고 이해 했습니다.)

하지만 결국 이 두 가지 훅을 활용한 커스텀 훅으로 상태 관리를 할 수 있는 건 명확한 한계가 있다. **훅을 적용하는 컴포넌트별로 초기화가 되기에 컴포넌트에 따라 서로 다른 상태를 가질 수 밖에 없는 지역 상태적인 문제가 상태를 파편화 한다.** 결국 이를 해결하기 위해선 컴포넌트 트리를 재설계 해야 하는 등의 수고로움이 필요하다.

## ✅ 질문

- 이나경: useState와 useReducer 둘다 유사하다고 나와있는데 언제 어떤 상황에서 어떤 것을 사용하는 것이 더 적합한지 궁금합니다.
    
    1. `useState` 활용
    
    - **목적**: 간단한 상태 값을 관리할 때 사용
    - **적합한 상황**:
        - 상태 값이 간단하고 독립적인 경우 (예: 숫자, 문자열, 불리언 값 등).
        - 상태 업데이트가 간단하고, 한 번에 하나의 값만 변경되는 경우.
        - 예: 텍스트 입력 필드, 버튼 클릭 상태 등
    
    1. `useReducer` 활용
    
    - **목적**: 상태 업데이트가 복잡하거나 여러 개의 상태를 관리할 때 사용합니다. 상태 값이 객체나 배열일 때 유용하며, 여러 액션에 따라 상태가 변하는 경우에 적합합니다.
    - **적합한 상황**:
        - 상태가 복잡하거나 여러 개의 상태를 관리해야 할 때.
        - 상태 업데이트가 여러 단계로 이루어지거나 여러 종류의 액션이 필요할 때.
        - 예: 다중 폼 필드, 상태가 서로 영향을 주는 경우, 여러 가지 액션 타입을 다뤄야 하는 경우.
    
    <aside> 💡
    
    저도 이 부분에서 “그래서 useState가 useReducer랑 뭔 차이가 있지?” 하는 의문을 가졌던 것 같아요. 명확하게 설명이 안 돼 있는 느낌..? chatGPT는 위처럼 답변을 주긴 하네요..!
    
    </aside>
    
- 나예진 : useState와 useReducer의 차이가 궁금하고, useReducer의 dispatch가 어떻게 동작하는지 궁금합니다(p.351)
    
    - `dispatch`는 `useReducer` 훅에서 제공하는 함수로, 이 함수는 액션 객체를 받아서 리듀서 함수에 전달합니다.
    - `dispatch`는 기본적으로 **액션 객체**를 전달하고, 리듀서는 이 액션을 처리하여 **상태 변경**을 결정합니다.
    - 액션 객체는 일반적으로 `type`과 추가 데이터를 포함하고 있으며, 리듀서 함수는 액션의 `type`을 확인하고 해당 작업을 수행합니다.
    
    <aside> 💡
    
    useState와 useReducer의 차이점은 나경님 질문과 비슷해서 위 답변을 참고 해주시면 좋을 것 같습니다!
    
    </aside>
    
- 최권진:저는 개인적으로 useState + context api는 상태관리 라이브러리 처럼 동작한다고 느꼈습니다. (상태 저장(useState), 전역 접근(공유, context api), 변경할 수 있기에(setter함수로) 그러면 useState(or useReducer) + Context API는 상태관리 라이브러리라고 볼 수 없을까요? 그렇다면, 상태 관리 라이브러리가 되기 위한 조건들이 어떤 것이 있는지 궁금합니다.
    
    저도 개인적인 견해로 말씀 드리면, 얼마나 딥하게 기준을 잡느냐에 따라 상태 관리 라이브러리로 볼 수도 있고, 아닐 수도 있다고 생각이 드네요.
    
    통상적으로 Context API는 전역 상태를 관리하기 위한 react 자체 기능으로 얘기를 하는데, 이 책에선 Context API의 관점 자체를 **props를 drilling 하지 않고 provider로 직접 주입했다**라고 보는 것 같아요(상태 변화를 체크해서 값을 주기보단, provider라는 도구로 props를 할당 해준다는 느낌?).
    
    저는 특정 액션에 따라 상태 변화가 일어나는 것을 컨트롤 하는 라이브러리가 상태 관리 라이브러리로서 작용된다고 이해 했습니다!