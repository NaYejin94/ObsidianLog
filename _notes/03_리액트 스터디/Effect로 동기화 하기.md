# Effect로 동기화하기

<aside> 💡

학습목표

✅ useEffect로 다뤄야 할 부수 효과에 대해서 구분해서 분류할 수 있다.

✅ 클린업 함수의 동작과 의미에 대해서 설명할 수 있고, 필요한 경우를 고려할 수 있다.

</aside>

## Effect란 무엇이고 이벤트와는 어떻게 다른가요?

컴포넌트 내부엔 2가지 로직 유형이 있습니다.

- **렌더링 코드** - 순수하게 props와 state를 이용해 JSX를 반환,
- **이벤트 핸들러** - ‘무언가’를 _하는_ 컴포넌트 내부의 중첩 함수, 특정 **사용자 작업으로 인해 발생하는 부수 효과**를 포함

➡️  `Effect`: 사용자의 동작으로 인해 발생하는 것이 아닌, **렌더링 자체에 의해 발생하는 부수 효과**

## Effect가 필요 없는 경우

- Effect는 보통 React를 벗어나 외부 시스템과 동기화하기 위해 사용됨 → 당신의 Effect가 React안에서 해결 가능한 범위인지 생각하자

## Effect를 작성하는 법

### 1단계: Effect 선언

```jsx
function MyComponent() {
  useEffect(() => {
    // 이곳의 코드는 *모든* 렌더링 후에 실행됩니다
  });
  return <div />;
}
```

_**useEffect 내부는 모든 렌더링 후에 실행된다. === 화면에 렌더링이 반영될 때까지 코드 실행을 “지연”시킨다.**_

⇒ 렌더링 중에 DOM 노드를 조작하려고 하면 오류 발생!⚠️ , useEffect로 감싸서 부수 효과를 처리해 렌더링 연산에서 분리한다.

### 2단계: Effect 의존성 지정

의존성 배열을 지정하는 동작을 통해 **Effect의 실행을 제어**하자. React는 [Object.is](http://Object.is) 비교를 통해 종속성 값이 이전과 동일한 경우 Effect를 다시 실행하지 않는다.

의존성을 “선택”할 수 없다: Effect 내부의 코드를 기반으로 평가해 React가 일차적으로 의존성 배열의 종속성을 감지하고 없으면 린트 에러가 발생함. 특정 종속성 변경에 코드가 다시 실행되길 원하지 않는다면? Effect 내부를 수정하여 그 종속성이 “필요”하지 않도록 만들어라

### 의존성 배열

[https://www.perplexity.ai/search/useeffectyi-yijonseong-baeyeol-YXVBbHvgQcKZmCjLx7ETgQ](https://www.perplexity.ai/search/useeffectyi-yijonseong-baeyeol-YXVBbHvgQcKZmCjLx7ETgQ)

- 의존성 배열에 넣어야하는 것들: Effect안에서 사용되는 것을 기준으로 한다.
    - **상태 변수**
    - **Props**
    - **컨텍스트** 값
    - **반응형 값**: 컴포넌트 범위 내에서 변하는 값
- 생략해도 괜찮은 것들
    - **안정적인 함수 참조**
    - **Refs**
    - **컴포넌트 외부에서 정의된 상수**
- ⭐특별한 경우
    - 함수 의존성 관리:
        - 이펙트 내에서만 사용되는 함수는 Effect 내부로 이동시킨다.
        - 다른 곳에서도 사용되는 함수는 useCallback으로 메모이제이션하고 의존성 배열에 포함한다.
        - 메모이제이션 되지 않고 정의된 함수는 매 렌더링마다 새로 생성되므로 불필요한 Effect 실행이 발생 할 수 있다.
    - 객체와 배열
        - 객체와 배열은 매 렌더링마다 새로 생성되며 참조가 달라지기에 의존성 배열에 포함하지 않는 것이 좋다.
        - 필요한 경우 useMemo를 사용하여 메모이제이션한다.
        - 객체 대신 필요한 특정 프로퍼티(원시값인 경우)만 의존성으로 사용한다.

### 3단계: 필요한 경우 클린업 함수 추가

<aside> 💡

React 개발 모드가 컴포넌트를 마운트 했다가 다시 마운트 하는 이유: 부수 효과가 제대로 종료되지 않은 경우를 쉽게 탐색할 수 있도록 하기 위해

마운트(Effect) → 언마운트(클린업 실행) → 다시 마운트(Effect)

</aside>

## 개발 중에 Effect가 두 번 실행되는 경우를 다루는 방법

**“어떻게 Effect가 다시 마운트된 후에도 작동하도록 고칠 것인가”라는 것이 옳은 질문입니다.?**

“어떻게 Effect가 다시 마운트된 후에도 작동하도록 고칠 것인가”란? 부수효과란 보통 React 외부와 연결하는 것을 의미하는데 이 부수효과를 잘 정리하는 것이 아닐까?

보통은 클린업 함수를 구현하는 것이 정답입니다.

### **React로 작성되지 않은 위젯 제어**

- 위젯의 상태를 React 상태와 동기화하는 Effect의 경우, **클린업 함수가 필요하지 않을 수 있습니다.**
- 하지만 일부 API는 연속적인 두 번의 호출을 허용하지 않을 수 있습니다 (예: <dialog> 요소의 showModal 메서드). 이 경우 **클린업 함수에서 해당 작업을 되돌리는 코드 (예: dialog.close())를 구현**해야 합니다.

### **이벤트 구독**

- Effect가 특정 이벤트 (예: 스크롤 이벤트)를 구독하는 경우, **클린업 함수에서 해당 구독을 해제해야 합니다(removeEventListener).**

### **애니메이션 트리거**

- Effect가 요소에 애니메이션을 적용하는 경우, **클린업 함수에서 애니메이션을 초기 상태로 재설정해야 합니다**.

### **데이터 페칭**

- Effect가 데이터를 가져오는 경우, **클린업 함수에서 진행 중인 fetch 요청을 무시하도록 처리해야 합니다.**(예: ignore 플래그 사용). 이미 시작된 네트워크 요청을 취소할 수는 없지만, 클린업 함수를 통해 더 이상 관련 없는 응답이 애플리케이션 상태에 영향을 미치지 않도록 보장해야 합니다. 개발 중에는 두 번의 fetch 요청이 발생할 수 있지만, 클린업 로직 덕분에 첫 번째 요청의 응답은 무시됩니다. 더 나은 해결책은 데이터 페칭 라이브러리나 클라이언트 측 캐시를 사용하는 것입니다.

### **분석 보내기**

- 페이지 방문과 같은 분석 이벤트를 보내는 Effect의 경우, **개발 환경에서 분석 이벤트가 두 번 호출되는 것을 수정하려고 하지 않는 것이 좋습니다**. 개발 환경의 로그가 제품 지표를 왜곡시키지 않도록 개발 환경에서는 분석 로직이 실제로 아무 작업도 수행하지 않도록 하는 것이 좋습니다. 제품 환경에서는 중복된 분석 로그가 발생하지 않습니다. 디버깅이 필요한 경우 스테이징 환경이나 개발 환경에서 Strict Mode를 일시적으로 비활성화하여 확인할 수 있습니다. 라우트 변경 이벤트 핸들러나 Intersection Observer를 사용하는 것도 대안이 될 수 있습니다.

**Effect가 아닌 경우: 애플리케이션 초기화의 경우 → 컴포넌트 외부에 배치할 수 있다.**

**Effect가 아닌 경우: 제품 구입하기 → 제품을 구입하는 것은 특정 상호 작용에 의해 발생하는 것으로 이벤트 핸들러 부분으로 이동시킨다.**

- **각각의 렌더링은 각각의 고유한 Effect를 갖습니다.**
    
    렌더링 결과물에 useEffect를 부착하는 것으로 생각할 수 있다.
    
    **렌더링 (1)→ Effect (1) → 렌더링 (2)→ Effect (2)→ Effect (1), Effect (2) 의존성 비교 → 비교 결과에 따라 이후 동작 달라짐**
    
    같으면 Effect (2) 무시
    
    다르면 Effect (1)의 클린업 함수 실행 후 Effect (2) 실행
    

# Effect가 필요하지 않을 수도 있습니다.

<aside> 💡

학습목표

✅ 다양한 예시를 통해서 Effect를 어디 사용하는 것이 좋은가 생각해볼 수 있다.

✅ useEffect 대신 사용하는 방법들에 대해서 고민해보고 리액트를 조금 더 효과적으로 설계할 수 있다.

</aside>

Effect는 React 패러다임을 벗어날 수 있는 탈출구 이지만, 불필요하게 Effect를 사용하는 경우도 있습니다. 그런 Effect를 제거하는 방법과 구분하는 방법에 대해서 알아봅시다.

## 불필요한 Effect를 제거하는 방법

### Effect가 필요하지 않은 두 가지 일반적인 경우

- **렌더링을 위해 데이터를 변환하는 데 Effect가 필요하지 않습니다.**
    - state를 사용하는 것이 올바를 방법입니다.
- **사용자 이벤트를 처리하는 데 Effect가 필요하지 않습니다.**
    - 사용자의 특정 동작에 반응하는 것은 이벤트 핸들러가 더 적절합니다.

### props 또는 state에 따라 state 업데이트하기

→ useEffect를 사용할 필요 없이 **파생된 상태**로 관리하면 좋습니다.

→ 파생된 상태란? 기존 상태로부터 연산을 통해 계산될 수 있는 상태를 의미합니다. 상태가 변경되면 컴포넌트의 연산이 다시 이뤄지기 때문에 파생된 상태도 다시 계산됩니다.

### 비용이 많이 드는 계산 캐싱하기

→ **메모이제이션** 하거나 **파생된 상태로 관리**하는 것이 더 낫습니다.

→ 콘솔 타임 로그를 통해 연산에 걸린 시간을 알 수 있습니다.

### prop 변경 시 모든 state 초기화

prop이 바뀌면 state를 초기화하는 로직

→ state를 초기화하고 싶은 컴포넌트에 **명시적인 key를 전달하여 React가 컴포넌트를 분리해서 관리**할 수 있게 하자. 그러면 **key가 달라지면 stata도 모두 재설정**합니다.

### prop이 변경될 때 일부 state 조정하기

→ **prop의 값을 이용해 렌더링 중에 ‘조정할 state’를 계산할 수 있도록 조정하기**

### 이벤트 핸들러 간 로직 공유

useEffect의 의존성 배열에 있는 값이 변경될 때만 실행된다는 이유로 특정 반복코드를 작성하고 싶을 수가 있다. 그러나 이는 적절하지 않다.

→ 어떤 코드가 Effect에 있어야 하는지 이벤트 핸들러에 있어야 하는지 확실하지 않은 경우 이 코드가 실행되어야 하는 _이유_를 자문해 보세요. **컴포넌트가 사용자에게 표시되었기 _때문에_ 실행되어야 하는 코드에만 Effect를 사용하세요.**

### POST 요청 보내기

→ 사용자 동작에 따른 부수 효과는 이벤트 핸들러를 사용하라!

### 연쇄 계산

서로를 트리거 하기 위한 여러 Effect를 연결하는 것은 비효율적이며, 버그가 발생할 가능성이 높습니다.

→ 렌더링 중에 가능한 것을 계산하고, 이벤트 핸들러에서 state를 조정하자

### state 변경을 부모 컴포넌트에게 알리기

→ state 변경을 부모 컴포넌트에서 관리하거나, 이벤트 핸들러 내에서 처리하기

### 부모에게 데이터 전달하기

→ 부모에서 데이터를 가져와서 자식에게 내려주어라

### 외부 저장소 구독하기

→ useSyncExternalStore 훅을 사용해서 외부 저장소를 구독하자

### 데이터 가져오기

useEffect를 이용해서 데이터를 가져오는 것은 흔하고 일반적인 일이지만, 오래된 응답을 무시하는 정리 함수를 추가해서 사용하는 것이 바람직하다.

→ Next.js와 같은 프레임워크를 사용하지 않는다면, useData와 같은 커스텀훅으로 추출하는 것을 고려하자 그렇게 하면 나중에 수정을 통해 효율적인 데이터 전략을 취할 수 있다.

# 반응형 effects의 생명주기

<aside> 💡

학습목표

✅ effect의 생명주기와 **반응형 값**에 대해서 알고, 설명할 수 있도록 학습한다.

</aside>

## effect의 생명주기

effects의 생명주기는 React 컴포넌트의 생명주기와는 조금 다른 것이 있다.

- 컴포넌트 생명주기
    - 컴포넌트는 화면에 추가될 때 마운트됩니다.
    - 컴포넌트는 일반적으로 상호작용에 대한 응답으로 새로운 props나 state를 수신하면 업데이트 됩니다.
    - 컴포넌트가 화면에서 제거되면 마운트가 해제됩니다.

### 동기화가 두 번 이상 수행되어야 하는 이유

컴포넌트가 그 자리에 그대로 있지만, effects의 연결은 다시 수행되어야 하는 경우가 있다. 이럴땐 effect가 연결을 중지하고 재 연결되어야 한다. 공식문서의 채팅방 예시 참고

### effect의 관점에서 생각하기

**대신 항상 한 번에 하나의 시작/중지 사이클에만 집중하세요. 컴포넌트를 마운트, 업데이트 또는 마운트 해제하는 것은 중요하지 않습니다. 동기화를 시작하는 방법과 중지하는 방법만 설명하면 됩니다. 이 작업을 잘 수행하면 필요한 횟수만큼 effect를 시작하고 중지할 수 있는 탄력성을 확보할 수 있습니다.**

### **React가 effect를 다시 동기화될 수 있는지 확인하는 방법**

→ 개발모드에서 즉시 강제로 동기화를 수행하여 effect가 다시 동기화할 수 있는지 확인합니다. (StrictMode)

### **React가 effect를 다시 동기화해야 한다는 것을 인식하는 방법**

**→ 의존성 배열의 종속성에 넣는 다는 것은 React한테 그 종속성이 변경되면 effect를 다시 동기화해야 한다는 것을 인식시키는 과정**입니다.

### 각 effect는 별도의 동기화 프로세스를 나타냅니다.

예를 들어 어떤 페이지에 방문할 때, 데이터를 연결하는 것과 그 페이지에 접속했다는 로그를 기록하고 싶을때**데이터를 연결하는 effect** / **접속했다는 로그를 기록하는 effect** 로 프로세스를 나눠서 분리해서 관리해야 한다.

프로세스 단위로 effect를 작성하자.

### 반응형 값에 “반응”하는 effect

종속성으로 지정하는 값은 그 값이 변하지 않는다면 종속성에 넣지 않아도 됩니다. 종속성에 넣어야하는 것은 **Props, state 및 렌더링 중에 계산되고 React 데이터 흐름에 참여하는 반응형 값인 경우입니다.**

### 빈 종속성이 있는 effect의 의미

컴포넌트의 관점에선, 빈 의존성 배열을 가진 effect가 컴포넌트가 마운트될 때만 동작하고 언마운트시 클린업 함수를 실행한다는 것을 의미하지만,

effect의 과점에선, 반응할 값이 없기 때문에 그저 동기화를 시작했다가 중지하는 것만 신경쓰면 된다.

### 컴포넌트 본문에서 선언된 모든 변수는 반응형입니다.

**컴포넌트 내부의 모든 값(컴포넌트 본문의 props, state, 변수 포함)은 반응형입니다. 모든 반응형 값은 다시 렌더링할 때 변경될 수 있으므로 반응형 값을 effect의 종속 요소로 포함해야 합니다.**

### React는 모든 반응형 값을 종속성으로 지정했는지 확인한다.

→ 안정적이라고 알고 있는 값들은 종속성으로 지정하지 않아도 되기에 ref, setState같은 것들은 React가 알아서 종속성에 포함하지 않아도 된다고 알고 있다.

### 다시 동기화하지 않으려는 경우 어떻게 해야 하나요?

→ 반응형 값이 아니라는 것을 증명하기 위해 여러가지 방법을 통해 린터에 “증명”할 수 있다.

1. 컴포넌트 외부로 옮기기
2. effect내부로 이동하기

## 결론

**effect는 반응형 코드 블록**입니다. 의존성 배열의 종속성이 변경되면 다시 동기화됩니다.

**종속성을 선택할 수 없습니다.** effect에서 읽은 모든 반응형 값이 종속성으로 포함되어 있어야 합니다.

- **effect가 독립적인 동기화 프로세스를 나타내는지 확인하세요.** effect가 아무것도 동기화하지 않는다면 [불필요한 것일 수 있습니다.](https://ko.react.dev/learn/you-might-not-need-an-effect) 여러 개의 독립적인 것을 동기화하는 경우 [분할](https://ko.react.dev/learn/lifecycle-of-reactive-effects#each-effect-represents-a-separate-synchronization-process)하세요.
- **props나 state에 “반응”하지 않고 effect를 다시 동기화하지 않고 최신 값을 읽으려면** effect를 반응하는 부분(effect에 유지할 것)과 반응하지 않는 부분(_effect 이벤트_ 라고 하는 것으로 추출할 수 있는 것)으로 분리하면 됩니다.
- **객체와 함수를 종속성으로 사용하지 마세요.** 렌더링 중에 오브젝트와 함수를 생성한 다음 effect에서 읽으면 렌더링할 때마다 오브젝트와 함수가 달라집니다. 그러면 매번 effect를 다시 동기화해야 합니다.