---

- 목적
    - 재사용성이 왜 중요한가?
        - 코드 중복, 유지보수 어려움, 협업 문제를 최소화 하기 위해
        - 재사용성을 높이기 위해 사용할 수 있는 패턴을 소개

# Compound Components

- 복합 컴포넌트
- 여러개의 관련된 컴포넌트를 하나의 그룹으로 묶어서 유용하게 동작하도록 설계
- React Context를 활용해 props drilling을 피한다.

```tsx
// Context 생성
const TabsContext = createContext();

// 부모 컴포넌트: Tabs
function Tabs({ children }) {
  const [activeTab, setActiveTab] = useState(0);

  return (
    <TabsContext.Provider value={{ activeTab, setActiveTab }}>
      <div>{children}</div>
    </TabsContext.Provider>
  );
}

// 탭 목록 컴포넌트: TabList
function TabList({ children }) {
  return <div>{children}</div>;
}

// 개별 탭 버튼: Tab
function Tab({ index, children }) {
  const { activeTab, setActiveTab } = useContext(TabsContext);
  const isActive = activeTab === index;

  return (
    <button onClick={() => setActiveTab(index)}>
      {children}
    </button>
  );
}

// 탭 내용: TabPanel
function TabPanel({ index, children }) {
  const { activeTab } = useContext(TabsContext);
  return activeTab === index ? <div>{children}</div> : null;
}

// 사용 예시
function App() {
  return (
    <Tabs>
      <TabList>
        <Tab index={0}>탭 1</Tab>
        <Tab index={1}>탭 2</Tab>
        <Tab index={2}>탭 3</Tab>
      </TabList>
      <TabPanel index={0}>탭 1의 내용입니다.</TabPanel>
      <TabPanel index={1}>탭 2의 내용입니다.</TabPanel>
      <TabPanel index={2}>탭 3의 내용입니다.</TabPanel>
    </Tabs>
  );
}
```

- Tabs는 상태(activeTab)를 관리하고 Context로 자식들에게 전달.
- Tab은 클릭 시 상태를 업데이트하고, 현재 활성화 여부를 스타일로 반영.
- TabPanel은 현재 선택된 탭에 맞는 내용만 렌더링.

**⇒ 장점**: Props를 직접 넘기지 않아도 Context로 상태를 공유하니 유연하고 알아보기 쉽다

# Render Props

[https://ko.legacy.reactjs.org/docs/render-props.html](https://ko.legacy.reactjs.org/docs/render-props.html)

- 렌더링 로직을 컴포넌트 외부로 위임해 재사용성을 높이는 방식
- 컴포넌트 내부에서 데이터를 관리하고, 그 데이터를 어떻게 렌더링할지는 **사용자**가 Props로 전달한 함수를 통해 결정
- 동적인 데이터, 특정 기능을 캡슐화 할 때 사용하는것이 좋다.

```tsx
// MouseTracker 컴포넌트
function MouseTracker({ render }) {
  const [position, setPosition] = useState({ x: 0, y: 0 });

  const handleMouseMove = (event) => {
    setPosition({
      x: event.clientX,
      y: event.clientY,
    });
  };

  return (
    <div onMouseMove={handleMouseMove}>
      {render(position)}
    </div>
  );
}

// 사용 예시
function App() {
  return (
    <div>
      <h1>마우스를 움직여보세요!</h1>
      <MouseTracker
        render={({ x, y }) => (
          <p>
            마우스 위치: ({x}, {y})
          </p>
        )}
      />
    </div>
  );
}
```

- MouseTracker는 마우스 위치를 추적하고, 그 데이터를 render 함수에 전달.
- 사용자는 render Props를 통해 위치 데이터를 원하는 대로 렌더링 가능.

# HOC (Higher-Order Components)

- 기존 컴포넌트를 감싸서 추가 기능을 주입하는 함수형 패턴
- 필요한 기능을 HOC로 분리해서 재사용성을 높임
- 상속 대신 합성을 활용

```tsx
// HOC 정의
function withAuth(WrappedComponent) {
  return function AuthComponent(props) {
    const isAuthenticated = false;

    if (!isAuthenticated) {
      return <p>로그인이 필요합니다.</p>;
    }

    return <WrappedComponent {...props} />;
  };
}

// 보호된 컴포넌트
function SecretPage() {
  return <h1>비밀 페이지에 오신 것을 환영합니다!</h1>;
}

// HOC 적용
const AuthenticatedSecretPage = withAuth(SecretPage);

// 사용 예시
function App() {
  return (
    <div>
      <AuthenticatedSecretPage />
    </div>
  );
}

```

- withAuth는 컴포넌트를 받아 인증 여부를 체크한 뒤, 조건에 따라 렌더링을 제어.
- SecretPage는 HOC에 의해 감싸져 인증된 경우에만 표시됨.

# 각 패턴의 장단점

|패턴|장점|단점|
|---|---|---|
|**Compound Components**|유연하고 가독성이 좋음|상태 공유가 필요하면 Context API가 필요할 수도 있음|
|**Render Props**|UI와 로직을 분리 가능|JSX가 복잡해질 수 있음|
|**HOC**|원본 컴포넌트를 수정하지 않고 기능 추가 가능|중첩되면 디버깅이 어려움|

⇒ useContext, useReducer등이 등장하면서 HOC와 Render Props는 사용빈도가 줄어들었음