# 이벤트에 응답하기

## 이벤트 핸들러란?

리액트의 컴포넌트는 종종 사용자 상호작용의 결과로 화면의 내용을 변경해야 하는 경우가 있습니다. 이때 리액트에서 이벤트 핸들러 함수를 정의 해서 특정 동작을 수행하도록 합니다.

## 정의 방법

- **함수 작성 후 prop으로 전달**
- **인라인으로 정의하기**

## 이벤트 핸들러 내에서 Prop 읽기

이벤트 핸들러는 해당 컴포넌트의 prop에 접근할 수 있다.

## 이벤트 핸들러를 Prop으로 전달하기

부모 컴포넌트에서 정의한 이벤트 핸들러를 자식컴포넌트의 prop으로 전달해서 자식 컴포넌트에서 사용할 수 있다.

## 이벤트 핸들러 Prop 명명하기

빌트인 컴포넌트는 onClick과 같은 브라우저 이벤트 이름만을 지원함. 그러나 사용자 정의 컴포넌트에선 이벤트 핸들러 prop의 이름을 원하는 대로 명명할 수 있음 보통 'on' + '원하는 이름'으로 명명합니다.

## 이벤트 전파

이벤트 버블링이라 부르는 현상도 리액트에서 마찬가지로 발생한다. e.stopPropagation()을 통해 이벤트가 부모 컴포넌트에 전파되지 않게 할 수 있다.

전파가 중단된 상황일 때, 부모 컴포넌트에서 자식 컴포넌트의 모든 이벤트를 캡처해 확인하고 싶으면 부모 컴포넌트에 'on' + '원하는 이벤트' + 'Capture' prop에 핸들러를 전달하면 실행된다.

사용예시

- 모달 내부 클릭 처리

## 전파의 대안으로 핸들러를 전달하게 된다면,

이벤트 전파를 막고, 명시적으로 부모의 핸들러를 호출하는 방식입니다.

- 어떤 핸들러가 실행되는지 추적하기 쉽다.
- 제어권을 분리할 수 있습니다.
- 자식과 부모 간의 역할이 분명해집니다.

## 기본 동작 방지하기

e.preventDefault()를 통해 브라우저의 기본 동작을 막습니다. 사용예시

- 폼 제출 방지
- 링크 클릭 방지 (a태그)
- input 요소

## 이벤트 핸들러가 사이드 이펙트를 가질 수도 있나요?

이벤트 핸들러는 사이드 이펙트를 위한 최고의 위치이다. 함수를 렌더링하는 것과 다르게 이벤트 핸들러는 순수할 필요가 없기에 무언가를 변경하는데 최적의 위치이다. 보통은 사이드 이펙트를 useEffect 훅에서 관리해야 한다고 생각할 수 있는데 ******

- _**사용자의 동작에 반응해야한다면 이벤트 핸들러**_를 사용하고,
- _**컴포넌트의 생명주기에 따르거나, props가 변경될 때 작업을 수행할 때는 useEffect 훅**_을 사용한다고 생각하면 좋다.

# State: 컴포넌트의 기억 저장소

컴포넌트별 메모리를 state라고 부른다.

## 일반 변수로 충분하지 않은 경우

- **지역 변수는 렌더링 간에 유지되지 않는다**.
- **지역 변수를 변경해도 렌더링을 일으키지 않는다.** => 렌더링 사이에 데이터를 유지하고, 새로운 데이터로 컴포넌트를 렌더링하도록 유발하는 과정이 필요하고 이를 `useState` 훅으로 구현하였다.

## state 변수 추가하기

`const [state, setState] = useState('초깃값');`

## useState 해부하기

useState를 호출하는 것은, React에 이 컴포넌트가 무언가를 기억하기를 원한다고 말하는 것

컴포넌트가 렌더링될 때마다, `useState` 는 다음 두 개의 값을 포함하는 배열을 제공합니다.

1. 저장한 값을 가진 state 변수
2. state 변수를 업데이트하고 React에 컴포넌트를 다시 렌더링하도록 유발하는 state setter 함수

### 실제 작동 방식

1. **컴포넌트가 처음 렌더링 될 때**, state에 useState('초깃값')로 전달한 초깃값을 반환합니다. React는 이 값을 최신 state 값으로 기억합니다.
2. **state를 업데이트할 때**, setState가 호출되면 React에서 기존에 기억한 값을 업데이트된 state값과 비교하여 렌더링을 유발하게 됩니다.
3. **컴포넌트가 리렌더링 됩니다**. React는 `useState('초깃값')`을 바라보지만, 이전에 업데이트한 state값을 기억해 업데이트된 state 값을 반환하게 됩니다.
4. 계속 반복

## 컴포넌트에 여러 state 변수 지정하기

하나의 컴포넌트에 여러 `state`를 가질 수 있습니다. 서로 연관이 없는 경우 분리해서 가지는 것이 좋지만 **연관이 있거나 함께 자주 변경하는 경우엔 두 state를 하나로 합치는 것이 더 좋을 수 있습니다.**

## React는 어떤 state를 반환할지 어떻게 알 수 있을까요?

setState 호출은 어떤 state 변수를 참조하는지에 대한 정보를 받지 못한다. 그렇다면 어떻게 state를 확인하고 업데이트 하는 것일까? 동일한 컴포넌트의 모든 렌더링에서 **안정적인 호출순서**에 **의존**하기 때문에 가능합니다. 첨부된 블로그 링크의 내용을 요약하자면,

1. React는 useState 훅이 실행될 때 state와 setter함수들의 배열을 세워놓는다.
2. 컴포넌트 안 최상위 수준에서만 훅 호출이란 규칙을 따라서 선언된 useState를 순서대로 호출한다.
3. 호출된 순서대로 state 배열 따로, setter 함수 배열을 따로 관리한다.
4. 순서대로 선언되었기 때문에 setter함수들은 자신의 커서 위치에 대한 참조를 가지고 있기 때문에 setState에서 state 정보를 참고하는 값을 전달하지 않아도 알 수가 있다.

## State는 격리되고 비공개로 유지됩니다.

State는 컴포넌트 인스턴스에 지역적이다. 동일한 컴포넌트를 두 번 렌더링한다면 각 복사본은 완전히 격리된 state를 가지게 됩니다. 다른 하나를 변경해도 다른 하나는 영향을 받지 않습니다. 이것이 state와 모듈 상단에 선언할 수 있는 보통의 변수와 구별하는 요소. state는 선언한 컴포넌트에 완전히 비공개이다. 부모 컴포넌트에서 알 수 없고, 이를 변경할 수 없다.

# 렌더링 그리고 커밋

![스크린샷 2025-04-04 오후 3.31.09.png](attachment:ee368e82-0b15-4b16-877b-f4e74b060a8d:%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-04-04_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.31.09.png)

## 1단계: 렌더링 트리거

컴포넌트 렌더링이 일어나는 데에는 두 가지 이유가 있다.

1. 컴포넌트의 초기 렌더링인 경우
2. 컴포넌트의 state가 업데이트된 경우

### 초기 렌더링

createRoot() 와 root.render()를 통해 작업을 수행함

### state 업데이트 시 리렌더링

컴포넌트가 처음으로 렌더링 된 후엔 setter함수를 통해 상태를 업데이트해 추가적인 렌더링을 트리거 할 수 있다. 컴포넌트의 상태를 업데이트하면 자동으로 렌더링 대기열에 추가된다.

![스크린샷 2025-04-04 오후 3.31.27.png](attachment:5e2eee04-172b-4a72-a8d0-bb5aa35320ee:%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-04-04_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.31.27.png)

## 2단계: React 컴포넌트 렌더링

렌더링을 트리거한 후엔 React는 컴포넌트를 호출하여 화면에 표시할 내용을 파악하게 됩니다. "렌더링"은 React에서 컴포넌트를 호출하는 것입니다.

- 초기 렌더링에서 React는 루트 컴포넌트를 호출합니다.
- 이후 렌더링에서 React는 state 업데이트가 일어나 렌더링을 트리거한 컴포넌트를 호출합니다. 재귀적 단계: 업데이트 된 컴포넌트가 다른 컴포넌트를 반환하면 React는 다음으로 해당 컴포넌트를 렌더링하고 해당 컴포넌트도 컴포넌트를 반환하면 반환된 컴포넌트를 다음에 렌더링합니다.

## 3단계: React가 DOM에 변경사항을 커밋

- 초기 렌더링의 경우 React는 appendChild() DOM API를 사용하여 생성한 모든 DOM 노드를 화면에 표시함
- 리렌더링의 경우 React는 필요한 최소한의 작업(리액트 파이버를 통해 계산한 것)을 적용하여 DOM이 최신 렌더링 출력과 일치하도록 한다. React는 렌더링 간에 차이가 있는 경우에만 DOM 노드를 변경합니다.

## 에필로그: 브라우저 페인트

렌더링이 완료되고 React가 DOM을 업데이트한 후 브라우저는 화면을 다시 그립니다.