## 5.2.2 앞서 설명한 지역 상태의 한계를 벗어나보자: useState의 상태를 바깥으로 분리하기

앞서 useState와 useReducer를 통한 상태관리를 살펴 본 결과 지역 상태라는 한계 때문에 여러 컴포넌트에 걸쳐 공유하기엔 수고로움이 있다. prop drilling과 같은 문제, 컴포넌트 설계의 복잡함 등등 그렇다면?

## 🔎 useState의 지역 상태가 아닌 완전히 다른 곳에서 상태를 관리하게 되면 어떨까?

→ 다음의 코드 예시를 따라 가면서 시도들 마다 어떤 문제점이 있는지 그걸 해결하기 위해 어떤 방법을 도입했는지 살펴보시죠.

1. p354 외부에서 상태를 관리하는 방법

![스크린샷 2025-03-25 오전 10.43.33.png](attachment:58844b33-4e08-4f5a-8f06-f1227a56f382:92ce26c4-79bb-4b13-a22c-83dd9cf058dd.png)

<aside> 💡

첫번째 방식의 코드는 전역으로 관리하기로 한 상태는 업데이트가 되지만, 상태변경과 함께 리렌더링이 호출되지 않기 때문에 실패에 가깝다

</aside>

그렇다면?

- 리렌더링을 유발시켜야 한다.

1. p355~356 useState를 사용해서 상태 변경시 리렌더링 유발

동영상

<aside> 💡

상태를 공유하는 다른 컴포넌트에 리렌더링이 유발되지 않았다. 이상하게 동작함

</aside>

원하는 동작은 상태가 변할 때 그 상태를 참조하는 컴포넌트들에게 모두 리렌더링을 유발하는 것 그러기 위해서 다음과 같은 요구사항을 만족해야 한다.

1. 컴포넌트 외부 어딘가에 상태를 두고 여러 컴포넌트가 같이 쓸 수 있어야 한다.
    
2. 그 상태를 사용하는 컴포넌트는 상태의 변화를 알아챌 수 있어야 하고 상태가 변화될 때마다 리렌더링이 일어나서 최신 상태값기준으로 렌더링해야 한다.
    
3. 상태가 객체인 경우 그 객체에 내가 감지하지 않는 값이 변한다 하더라도 리렌더링이 발생해서는 안된다.
    
4. p357 ~ 366 개선점을 모두 반영한 최종안
    

동영상

<aside> 💡

일반적으로 사용하는 상태 관리 라이브러리의 형태

</aside>

1. createStore란 전역 상태를 만들고 이를 참조할 수 있게 하는 useStore라는 커스텀훅을 구현해서 상태를 관리한다.
2. 객체로 구성된 store의 경우 useStoreSelector훅을 통해 컴포넌트에서 필요한 값만 골라서 사용할 수 있다.

### useSubscription과 책에서 만든 useStore의 차이점

- selector와 subsribe에 대한 비교를 추가했다. 더 안정적으로 상태를 제공할 수 있게 하는 안전장치로 볼 수 있음
- useSubscription 훅은 리액트 18버전에서 useSyncExternalStore로 재작성되었다.

---

## 5.2.3 useState와 Context를 동시에 사용해 보기

앞서 만든 useStore 내지는 useStoreSelector 훅을 활용해 상태 관리 라이브러리처럼 이용해 봤는데 이 경우에도 한 가지 단점이 있다.

→ 이 훅과 스토어를 사용하는 구조는 반드시 하나의 스토어만 가지게 된다는 것입니다.

이를 해결하기 위해 리액트의 Context를 활용해서 자신이 주입된 스토어에 대해서만 접근할 수 있게 될 것이다. 그렇게 한다면 스토어의 범위를 지정해 줄 수 있을 것이며 이는 전역 상태와 분리되어 사용할 수 있습니다.

### Context와 Provider를 기반으로 각 store 값을 격리해서 관리하는 경우의 장점

- 스토어를 사용하는 컴포넌트는 해당 상태가 어느 스토어에서 온 상태인지 신경 쓰지 않아도 된다.
- Context와 Provider를 관리하는 부모 컴포넌트의 입장에선 자신이 자식 컴포넌트에 따라 보여 주고 싶은 데이터를 Context로 잘 격리하기만 하면 된다.

### 상태 관리 라이브러리의 작동 방식 요약

<aside> 💡

useState, useReducer가 가지고 있는 한계, 컴포넌트 내부에서만 사용할 수 있는 지역 상태라는 점을 극복하기 위해 외부 어딘가에 상태를 둔다.

이 외부의 상태 변경을 각자의 방식으로 감지해 컴포넌트의 렌더링을 일으킨다.

</aside>

## 5.2.4 상태 관리 라이브러리 Recoil, Jotai, Zustand 살펴보기

최근 각광받고 있는 Recoil, Jotai, Zustand에 대해서 알아보자, 세 상태 관리 라이브러리가 지향하는 목적은 무엇이고, 어떻게 상태를 관리하며, 이 상태를 각 컴포넌트로 어떻게 전파해 렌더링을 일으키는지에 대해서 살펴보는 챕터이다.

### Recoil

- `RecoilRoot`: Recoil에서 생성되는 상태값을 저장하기 위한 스토어를 생성함. 최상위 컴포넌트에서 선언해야 한다.
    - Recoil의 상태값은 RecoilRoot로 생성된 Context의 스토어에 저장된다.
    - 스토어의 상태값에 접근할 수 있는 함수들이 있으며, 이 함수를 활용해 상태값에 접근하거나 상태값을 변경할 수 있다.
    - 값의 변경이 발생하면 이를 참조하고 있는 하위 컴포넌트에 모두 알린다.
- `atom`: 상태를 나타내는 Recoil의 최소 상태 단위
    - key값을 필수로 가지며, 이 키는 다른 atom과 구별하는 식별자가 되는 필수 값이다.
- `useRecoilValue`: atom의 값을 읽어오는 훅
- `useRecoilState`: useState와 유사하게 값을 가져오고, 또 이 값을 변경할 수도 있는 훅

**특징**

- 메타 팀에서 주도적으로 개발하고 있기에 리액트의 업데이트를 지원할 것으로 기대됨
- selector를 필두로 다양한 비동기 작업을 지원하는 API를 제공하고 있기 때문에 추가적인 미들웨어를 사용하지 않아도 비동기 작업을 수월하게 처리할 수 있다.

⇒ 2025년 3월 현재까지도 1.0.0이 나오지 않았고, 1년이상 업데이트가 이뤄지지 않아서 사용하는 것을 추천하지 않는다고 한다.

### Jotai

- Recoil의 atom 모델에 영감을 받아 만들어진 상태 관리 라이브러리 상향식 접근 법으로 작은 단위의 상태를 위로 전파할 수 있는 구조를 취하고 있다.
    
- `atom`: Recoil과 마찬가지로 최소 단위의 상태를 의미함 atom하나만으로도 상태를 만들 수도, 파생된 상태를 만들 수도 있다.
    
- `useAtomValue`
    
    - useReducer에서 반환하는 상태값은 [store의 버전, atom에서 get을 수행했을 때 반환되는 값, atom 그자체] 3가지이다.
        
        useAtomValue 훅 내부에서 useReducer가 반환하는 [store의 버전, atom에서 get을 수행해 반환된 값, atom 그 자체]의 3가지 상태값은 각각 서로 다른 역할을 수행하며, 이를 통해 상태 관리를 좀 더 세밀하고 효율적으로 할 수 있게 됩니다.
        
        ## 반환값의 의미
        
        - **store의 버전**
            - 이 값은 글로벌 상태(store)의 업데이트 버전을 나타냅니다.
            - store의 버전은 atom에 기반한 값이 변경될 때마다 갱신되므로, 컴포넌트가 최신 상태로 리렌더링되어야 하는 시점을 감지하는 역할을 합니다.
        - **atom에서 get을 수행했을 때 반환된 값**
            - 이는 해당 atom을 통해 도출된 실제 상태 값입니다.
            - 컴포넌트에서는 이 값을 사용하여 렌더링해야 할 데이터를 얻으며, 값 자체의 변경 여부에 따라 실제 사용자 인터페이스가 업데이트됩니다.
        - **atom 그 자체**
            - atom 객체 자체를 포함함으로써, 동일한 atom을 참조하고 있는지 혹은 새 atom으로 교체되었는지를 감지할 수 있습니다.
            - 이 구성은 동일한 atom임에도 불구하고 store의 다른 변화가 있을 때 불필요한 재계산이나 리렌더링을 피하는 데 도움을 줍니다.
        
        ## 요약
        
        이 세 가지 값의 결합은 useAtomValue가 단순히 값 하나만 반환하는 것이 아니라, 상태 업데이트에 필요한 다양한 정보를 함께 관리하여 컴포넌트가 정확히 어떤 변화에 반응해야 할지 판단하도록 돕습니다. 즉, store의 버전은 변경 감지를, 실제 값은 사용자 데이터 제공을, atom 자체는 동일성 비교 및 디버깅에 유용한 정보를 제공합니다. 이러한 구조 덕분에 Jotai는 효율적이면서도 세밀한 상태 관리를 구현할 수 있습니다.
        
        ---
        
        Perplexity로부터의 답변: [pplx.ai/share](https://www.perplexity.ai/search/pplx.ai/share)
        
    - Recoil과는 다르게 컴포넌트 루트 레벨에서 Context가 존재하지 않아도 된다.
        
    - **WeakMap**
        
        WeakMap은 ES6에서 도입된 JavaScript 데이터 구조로, 객체만을 키로 사용하고 값은 어떤 것이든 저장할 수 있는 키-값 쌍의 컬렉션입니다[5](https://www.freecodecamp.org/news/weakmap-and-weakset-in-javascript/). 일반 Map과 달리 WeakMap은 키에 대한 "약한 참조(weak reference)"를 유지한다는 특징이 있습니다[2](https://velog.io/@holim0/Map%EA%B3%BC-WeakMap).
        
        ## Map이란 무엇인가?
        
        WeakMap과는 달리 모든 값을 키로 지정할 수 있는 자료구조이다. 객체와 비슷하게 생각할 수 있지만 다음과 같이 비교할 수 있습니다.
        
        # 일반 객체 vs Map vs WeakMap 비교표
        
        |특성|일반 객체 (Object)|Map|WeakMap|
        |---|---|---|---|
        |**키 타입**|문자열, Symbol만 가능|모든 값(객체, 함수, 원시값 등)|객체만 가능|
        |**순서 보존**|ES2015 이후 부분적 보존|삽입 순서 완벽 보존|해당 없음 (순회 불가)|
        |**크기 확인**|Object.keys(obj).length|size 속성|제공하지 않음|
        |**순회 방법**|for...in, Object.keys() 등|for...of, forEach, keys(), values()|순회 불가능|
        |**참조 방식**|강한 참조|강한 참조|약한 참조 (가비지 컬렉션 대상)|
        |**프로토타입 체인**|있음|없음|없음|
        |**성능 (많은 데이터)**|상대적으로 느림|빠름|빠름|
        |**주요 메서드**|기본 속성 접근 (.prop, ['prop'])|set(), get(), has(), delete(), clear()|set(), get(), has(), delete()|
        |**주요 사용 사례**|일반적인 데이터 저장|키-값 데이터 관리, 순서 중요 시|객체 메타데이터 저장, 메모리 관리|
        |**메모리 관리**|수동 관리 필요|수동 관리 필요|자동 가비지 컬렉션|
        
        ---
        
        Perplexity로부터의 답변: [pplx.ai/share](https://www.perplexity.ai/search/pplx.ai/share)
        
        ## WeakMap의 특징
        
        **약한 참조**: WeakMap의 가장 큰 특징은 키로 사용된 객체에 대한 약한 참조를 유지한다는 점입니다. 이는 객체에 대한 참조가 WeakMap 외에 존재하지 않는다면, 해당 객체는 가비지 컬렉션의 대상이 되어 자동으로 메모리에서 제거된다는 의미입니다[2](https://velog.io/@holim0/Map%EA%B3%BC-WeakMap)[4](https://ko.javascript.info/weakmap-weakset).
        
        **메서드**: WeakMap은 다음과 같은 주요 메서드를 제공합니다[1](https://playcode.io/javascript/weak-map)[2](https://velog.io/@holim0/Map%EA%B3%BC-WeakMap):
        
        - `set(key, value)`: 키-값 쌍을 추가합니다
        - `get(key)`: 키에 해당하는 값을 반환합니다
        - `has(key)`: 키가 존재하는지 확인합니다
        - `delete(key)`: 키-값 쌍을 삭제합니다
        
        ## WeakMap의 사용 사례
        
        WeakMap은 주로 다음과 같은 상황에서 유용하게 사용됩니다:
        
        1. **부가적인 데이터 저장**: 객체에 추가 데이터를 저장해야 하지만, 해당 객체가 메모리에서 제거될 때 함께 제거되어야 하는 경우
            
            ```jsx
            const cache = new WeakMap();
            
            function expensiveOperation(obj) {
              if (cache.has(obj)) {
                console.log("Returning cached result");
                return cache.get(obj);
              }
            
              console.log("Performing expensive operation");
              const result = /* 비용이 많이 드는 연산 수행 */;
              cache.set(obj, result);
              return result;
            }
            
            const obj = { /* 일부 데이터 */ };
            expensiveOperation(obj); // "Performing expensive operation"
            expensiveOperation(obj); // "Returning cached result"
            
            ```
            
        2. **캐싱**: 객체를 키로 사용하여 계산 결과를 캐싱할 때, 객체가 더 이상 필요하지 않을 경우 자동으로 캐시도 정리됩니다
            
            ```jsx
            const cache = new WeakMap();
            
            function expensiveOperation(obj) {
              if (cache.has(obj)) {
                console.log("Returning cached result");
                return cache.get(obj);
              }
            
              console.log("Performing expensive operation");
              const result = /* 비용이 많이 드는 연산 수행 */;
              cache.set(obj, result);
              return result;
            }
            
            const obj = { /* 일부 데이터 */ };
            expensiveOperation(obj); // "Performing expensive operation"
            expensiveOperation(obj); // "Returning cached result"
            
            ```
            
        3. **DOM 요소 관련 데이터 저장**: DOM 요소에 추가 정보를 저장할 때, 요소가 DOM에서 제거되면 관련 데이터도 자동으로 정리됩니다
            
            ```jsx
            const domData = new WeakMap();
            
            function attachData(element, data) {
              domData.set(element, data);
            }
            
            function getData(element) {
              return domData.get(element);
            }
            
            const div = document.createElement('div');
            attachData(div, { clickCount: 0 });
            
            div.addEventListener('click', () => {
              const data = getData(div);
              data.clickCount++;
              console.log(`Clicked ${data.clickCount} times`);
            });
            
            ```
            
        
        ## jotai에서의 WeakMap 활용
        
        jotai의 store에서 atom 객체를 키로 활용하는 방식은 WeakMap의 전형적인 사용 사례입니다. 이렇게 함으로써 다음과 같은 이점을 얻을 수 있습니다:
        
        4. atom 객체가 더 이상 참조되지 않을 때 관련 데이터가 자동으로 메모리에서 정리됩니다.
        5. atom 객체 자체를 수정하지 않고도 관련 상태를 저장할 수 있습니다.
        6. 메모리 누수를 방지하면서 atom과 관련된 값을 효율적으로 관리할 수 있습니다.
        
        이러한 방식은 특히 많은 atom을 동적으로 생성하고 제거하는 애플리케이션에서 메모리 관리에 큰 도움이 됩니다.
        
- `useAtom`: useState와 유사하게 동작해서 사용가능하다.
    

**특징**

- Recoil의 atom 개념을 도입하면서도 API가 간결함 atom마다 키를 관리할 필요가 없다. → 객체의 참조를 WeakMap에 보관해 해당 객체 자체가 변경되지 않는 한 별도의 키가 없이도 객체의 참조를 통해 값을 관리한다.
- type을 지원하며 리액트 18의 변경된 API또한 원할하게 지원하며 정식 출시돼어 있어 서비스 채택이 가능하다.

### Zustand

- 하나의 스토어를 중앙 집중형으로 활용해 스토어 내부에서 상태를 관리한다.
- setState가 partial, replace로 나눠져 있어 state 일부 변경하거나 새로운 값으로 변경할 때를 나눠서 사용할 수 있다.

**특징**

- 많은 코드를 작성하지 않아도 빠르게 스토어를 만들고 사용할 수 있다. 리덕스 대비 간단하고 빠르게 상태를 정의할 수 있다. → 가볍고 편리하다
- Zustand 자체의 라이브러리 크기가 2.9kb로 작아서 유리한 점이 있고 쉽게 접근하기 좋다.
- 리덕스와 마찬가지로 미들웨어를 지원하단. create의 두 번째 인수로 원하는 미들웨어를 추가하여 사용가능하다. persist(스토어 데이터를 영구히 보존), immer(객체를 관리하기 쉽게 도와줌) 등 추가적인 작업을 정의할 수 있게 도와준다.

### 세 라이브러리 비교를 위한 counter 예제

```jsx
//Recoil
import { atom, useRecoilState } from 'recoil';

const counterState = atom({
  key: 'counterState',
  default: 0,
});

function Counter() {
  const [count, setCount] = useRecoilState(counterState);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

```jsx
//Jotai
import { atom, useAtom } from 'jotai';

const counterAtom = atom(0);

function Counter() {
  const [count, setCount] = useAtom(counterAtom);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

```jsx
//Zustand
import create from 'zustand';

const useStore = create(set => ({
  count: 0,
  increment: () => set(state => ({ count: state.count + 1 })),
}));

function Counter() {
  const { count, increment } = useStore();

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
}
```

## 5.2.5 정리

리액트에서 리렌더링을 일으키기 위한 방식은 제한적이기 때문에 어떠한 방식으로 상태를 관리하든지 간에 리렌더링을 만드는 방법은 모두 거의 동일하다.

따라서 라이브러리별 특징을 잘 파악하고, 에플리케이션의 상황과 철학에 맞는 상태 관리 라이브러리를 적절하게 선택해 사용하는 것이 좋다.

관리가 잘되는 라이브러리를 선택하는 것이 좋다

이나경: 388쪽에 나오는 자바스크립트에서 객체만을 키로 가질 수 있는 독특한 방식의 Map인 WeakMap에 대한 설명과 언제 사용하는지 알고싶습니다.

나예진 : 프로젝트 규모나 요구사항에 따라 어떤 상태 관리 라이브러리를 선택하는게 좋을까요?

최권진: 프로젝트 규모가 작을 때는 Zustand나 Context API처럼 간단한 상태관리 방식으로 시작해도 되지만, 사용자 수가 점점 늘어나고, 프로젝트 구조가 복잡해질 걸 고려하면 처음부터 Redux처럼 구조화된 상태관리 라이브러리를 쓰는 게 더 낫지 않나요? Zustand로 상태관리를 시작했다가 서비스가 커지면, 이미 상태 관리 구조가 코드 전반에 퍼져 있어서 결국 싹 리팩토링해야 할 수도 있을 것 같은데요. 그렇다면 왜 이렇게 다양한 상태관리 라이브러리들이 존재하는 걸까요? 각 상황마다 굳이 다른 걸 쓰는 이유가 궁금해요.

## 예진님 & 권진님

# 프로젝트 규모와 요구사항에 따른 React 상태 관리 라이브러리 선택 가이드

상태 관리는 React 애플리케이션 개발에서 핵심적인 부분입니다. 프로젝트 규모와 복잡성에 따라 적절한 상태 관리 라이브러리를 선택하는 것은 애플리케이션의 성능, 유지보수성, 그리고 개발 경험에 큰 영향을 미칩니다. 이 보고서에서는 다양한 상태 관리 라이브러리의 특징과 적합한 사용 사례를 분석하고, 프로젝트 확장성 측면에서의 고려사항을 살펴보겠습니다.

## 주요 상태 관리 라이브러리 비교

## Context API: 리액트의 내장 솔루션

Context API는 리액트에 내장된 상태 관리 솔루션으로, 추가 라이브러리 없이 간단한 상태 관리를 구현할 수 있습니다.

- **장점**: 설정이 간단하고 추가 패키지가 필요 없음, 직관적인 API[14](https://f-lab.kr/insight/react-state-management)
- **단점**: 상태가 복잡해지거나 여러 컨텍스트를 사용할 때 코드의 가독성과 유지보수성이 떨어질 수 있음, 성능 최적화에 제한이 있음[15](https://f-lab.kr/insight/react-state-management-20240516)

```jsx
*// Context API 사용 예제*
import React, { createContext, useContext, useState } from 'react';

*// Context 생성*
const UserContext = createContext();

export const UserProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  return (
    <UserContext.Provider value={{ user, setUser }}>
      {children}
    </UserContext.Provider>
  );
};

export function useUser() {
  return useContext(UserContext);
}
```

## Redux: 구조화된 상태 관리의 표준

Redux는 오랫동안 React 생태계에서 가장 인기 있는 상태 관리 라이브러리로, 예측 가능한 상태 관리를 제공합니다.

- **장점**: 구조화된 패턴, 강력한 개발자 도구(Redux DevTools), 풍부한 미들웨어와 플러그인 지원, 대규모 프로젝트에 적합[1](https://velog.io/@kimhi1105/%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%9D%98-%EC%83%81%ED%83%9C%EA%B4%80%EB%A6%AC%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC)[9](https://f-lab.kr/insight/react-state-management-20241227)
- **단점**: 보일러플레이트 코드가 많음, 학습 곡선이 높음, 설정이 복잡함[1](https://velog.io/@kimhi1105/%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%9D%98-%EC%83%81%ED%83%9C%EA%B4%80%EB%A6%AC%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC)[2](https://velog.io/@iberis/%EC%83%81%ED%83%9C%EA%B4%80%EB%A6%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EB%B9%84%EA%B5%90-Redux-vs-Recoil-vs-Zustand-vs-Jotai)

## Zustand: 간결함과 성능의 균형

Zustand는 Redux의 복잡성을 해결하면서도 유사한 패턴을 유지하는 라이브러리입니다.

- **장점**: 최소한의 보일러플레이트, 직관적인 API, 가벼운 번들 사이즈(3.1kb), 컴포넌트 외부에서도 상태 접근 가능[4](https://bandal.dev/React/state-management)[6](https://it2u.tistory.com/15)
- **단점**: Redux에 비해 개발자 도구와 생태계가 제한적[6](https://it2u.tistory.com/15)

```jsx
*// Zustand 사용 예제*
import { create } from "zustand";

*// Zustand 상태 정의*
const useUserStore = create((set) => ({
  user: null,
  setUser: (user) => set({ user }),
}));
```

## Recoil과 Jotai: 원자적 상태 관리

Recoil과 Jotai는 원자 단위로 상태를 관리하는 새로운 패러다임을 제시합니다.

- **장점**: 세분화된 상태 관리, Suspense와의 통합, 불필요한 리렌더링 최소화[2](https://velog.io/@iberis/%EC%83%81%ED%83%9C%EA%B4%80%EB%A6%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EB%B9%84%EA%B5%90-Redux-vs-Recoil-vs-Zustand-vs-Jotai)[3](https://yozm.wishket.com/magazine/detail/2233/)
- **단점**: Recoil은 실험 단계에서 더 이상 활발한 업데이트가 없으며, 안정적인 DevTool이 부족함[2](https://velog.io/@iberis/%EC%83%81%ED%83%9C%EA%B4%80%EB%A6%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EB%B9%84%EA%B5%90-Redux-vs-Recoil-vs-Zustand-vs-Jotai)

## 프로젝트 규모에 따른 선택 가이드

## 소규모 프로젝트

소규모 프로젝트에서는 Context API나 Zustand를 사용하는 것이 적합합니다. 이들은 설정이 간단하고 직관적인 API를 제공하여 빠르게 개발을 시작할 수 있습니다[5](https://wolhyong.tistory.com/entry/Nextjs-14-%EA%B0%95%EC%9D%98-18%EA%B0%95-Redux-%EB%98%90%EB%8A%94-Zustand%EB%A1%9C-%EC%83%81%ED%83%9C-%EA%B4%80%EB%A6%AC-%ED%99%95%EC%9E%A5)[9](https://f-lab.kr/insight/react-state-management-20241227).

`textContext API는 간단한 상태 관리에 적합하고 리액트 내장 기능이라는 장점이 있지만, 복잡한 상태 관리에는 한계가 있습니다. 반면, Redux는 복잡한 상태 관리와 미들웨어의 사용에 강점을 가지고 있지만, 학습 곡선과 초기 설정 비용이 높습니다.`

## 중간 규모 프로젝트

중간 규모 프로젝트에서는 Zustand가 균형 잡힌 선택이 될 수 있습니다. 간결한 API와 적은 보일러플레이트로 Redux와 유사한 패턴을 제공하면서도 더 적은 코드로 동일한 기능을 구현할 수 있습니다[4](https://bandal.dev/React/state-management)[8](https://www.marcus-log.dev/posts/journey-zustand).

## 대규모 프로젝트

대규모 복잡한 프로젝트에서는 Redux가 여전히 강점을 가집니다. 강력한 개발자 도구, 풍부한 미들웨어, 그리고 예측 가능한 상태 흐름은 대규모 팀과 복잡한 상태 관리에 적합합니다[9](https://f-lab.kr/insight/react-state-management-20241227)[12](https://orezytivarg.github.io/redux-faq-performance/).

## 확장성 고려와 마이그레이션 전략

## 처음부터 Redux를 사용해야 할까?

처음부터 Redux를 사용하는 것은 장단점이 있습니다. Redux의 구조화된 패턴은 확장성에 유리하지만, 소규모 프로젝트에서는 과도한 복잡성을 초래할 수 있습니다. 최근에는 많은 신규 프로젝트에서 Redux 대신 Zustand나 Jotai를 선택하는 추세가 있습니다[1](https://velog.io/@kimhi1105/%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%9D%98-%EC%83%81%ED%83%9C%EA%B4%80%EB%A6%AC%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC)[3](https://yozm.wishket.com/magazine/detail/2233/).

`하지만 신사업이나 새로 하는 프로젝트에서는 리덕스는 많이 쓰이고 있지 않으며, 리덕스를 세팅할 때 많은 세팅이 필요하고 배우기 어렵기 때문에 리덕스를 안쓴다고 한다.`

## 실제 마이그레이션 사례

원티드 인사이트 팀은 Redux에서 Zustand로 마이그레이션하는 과정을 성공적으로 진행했으며, 이 과정에서 다음과 같은 전략을 사용했습니다[8](https://www.marcus-log.dev/posts/journey-zustand):

1. Redux Saga를 통한 API 핸들링을 React Query로 이관
2. 꼭 필요한 전역 상태만 Zustand로 관리
3. 지역 상태로 관리 가능한 비즈니스 로직은 지역 상태(state)로 이동

## 왜 다양한 상태 관리 라이브러리가 존재하는가?

## 다양한 프로젝트 요구사항

모든 프로젝트에 적합한 단일 상태 관리 솔루션은 존재하지 않습니다. 프로젝트의 규모, 복잡성, 성능 요구사항에 따라 다른 접근 방식이 필요합니다[11](https://f-lab.kr/insight/understanding-state-management-and-frameworks-in-frontend-development)[13](https://f-lab.kr/insight/state-management-and-component-optimization-in-react).

## 개발자 경험 향상

Redux의 보일러플레이트와 복잡성은 많은 개발자들이 더 간결하고 직관적인 API를 제공하는 대안을 찾게 만들었습니다. Zustand와 같은 라이브러리는 이러한 요구에 대응하여 개발자 경험을 향상시키고자 합니다[7](https://momoci99.github.io/CompareRTKandZustand/)[8](https://www.marcus-log.dev/posts/journey-zustand).

## 다양한 상태 관리 패러다임

서로 다른 라이브러리는 다양한 상태 관리 패러다임을 제공합니다:

- Flux 패턴: Redux, Zustand
- 원자적 상태: Recoil, Jotai
- 반응형: MobX

이러한 다양한 패러다임은 서로 다른 프로젝트 요구사항과 개발자 선호도에 맞게 선택할 수 있는 유연성을 제공합니다[3](https://yozm.wishket.com/magazine/detail/2233/).

## 결론: 프로젝트에 적합한 라이브러리 선택하기

상태 관리 라이브러리를 선택할 때는 프로젝트의 현재 요구사항뿐만 아니라 미래의 확장 가능성도 고려해야 합니다. Redux는 구조화된 접근 방식으로 대규모 프로젝트에 적합한 반면, Zustand는 간결함과 성능의 균형을 제공합니다.

처음부터 Redux로 시작해야 한다는 규칙은 없으며, 점진적 마이그레이션 전략을 통해 필요에 따라 상태 관리 방식을 변경할 수 있습니다. 중요한 것은 프로젝트의 특성을 이해하고, 팀의 경험과 선호도를 고려하여 적절한 선택을 하는 것입니다.

`지금 배우려고 한다면 내가 지원하고자 하는 회사에서 쓰고 있는 상태 관리 라이브러리를 선택해서 공부하는 것이 가장 베스트다.`

결국, 다양한 상태 관리 라이브러리가 존재하는 이유는 서로 다른 프로젝트 요구사항과 개발자 선호도를 충족시키기 위함입니다. 상황에 맞는 적절한 도구를 선택하는 것이 성공적인 프로젝트 개발의 핵심입니다.

### 프로젝트의 어떤 특성을 고려해야 하는가?

프로젝트의 특성에 따라 상태관리 라이브러리를 선택할 때 고려해야 할 주요 요소들은 다음과 같습니다:

## 프로젝트 규모와 복잡성

- **소규모 프로젝트**: React의 내장 상태관리(useState, useContext)만으로도 충분할 수 있습니다.
- **중규모 프로젝트**: Zustand나 Recoil과 같은 간단하고 직관적인 라이브러리가 적합할 수 있습니다[1](https://blog.soaple.io/entry/%EC%96%B4%EB%96%A4-%EC%83%81%ED%83%9C%EA%B4%80%EB%A6%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EB%A5%BC-%EC%8D%A8%EC%95%BC%ED%95%A0%EA%B9%8C)[3](https://insight.infograb.net/blog/2024/11/20/client-state/).
- **대규모 프로젝트**: Redux와 같은 강력한 상태관리 도구가 필요할 수 있습니다. 복잡한 상태 로직과 많은 컴포넌트 간의 상태 공유를 효과적으로 관리할 수 있습니다[1](https://blog.soaple.io/entry/%EC%96%B4%EB%96%A4-%EC%83%81%ED%83%9C%EA%B4%80%EB%A6%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EB%A5%BC-%EC%8D%A8%EC%95%BC%ED%95%A0%EA%B9%8C).

## 성능 요구사항

- **높은 성능이 필요한 경우**: Zustand나 Jotai와 같은 최소한의 리렌더링을 제공하는 라이브러리를 고려할 수 있습니다[3](https://insight.infograb.net/blog/2024/11/20/client-state/)[7](https://bandal.dev/React/state-management).
- **실시간 데이터 처리**: MobX와 같은 반응형 프로그래밍 모델을 제공하는 라이브러리가 유용할 수 있습니다.

## 팀의 경험과 학습 곡선

- **Redux 경험이 많은 팀**: Redux 또는 Redux Toolkit을 사용하는 것이 유리할 수 있습니다.
- **빠른 학습이 필요한 경우**: Zustand나 Recoil과 같이 간단한 API를 제공하는 라이브러리가 적합할 수 있습니다[3](https://insight.infograb.net/blog/2024/11/20/client-state/)[7](https://bandal.dev/React/state-management).

## 상태의 종류

- **서버 상태 관리**: React Query나 SWR과 같은 서버 상태 관리에 특화된 라이브러리를 고려해볼 수 있습니다[5](https://velog.io/@hozzijeong/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%84%A0%ED%83%9D).
- **클라이언트 상태 관리**: Zustand, Redux, Recoil 등을 사용할 수 있습니다[3](https://insight.infograb.net/blog/2024/11/20/client-state/).

## 확장성 및 유지보수성

- **장기 프로젝트**: 타입 안정성과 강력한 개발자 도구를 제공하는 Redux나 MobX를 고려할 수 있습니다[6](https://thisisdevelop.com/entry/frontendframework).
- **유연성이 필요한 경우**: Zustand와 같이 유연한 API를 제공하는 라이브러리가 적합할 수 있습니다[7](https://bandal.dev/React/state-management).

## 커뮤니티 지원 및 생태계

- **광범위한 지원이 필요한 경우**: Redux와 같이 큰 커뮤니티와 풍부한 생태계를 가진 라이브러리를 선택할 수 있습니다[6](https://thisisdevelop.com/entry/frontendframework).
- **최신 트렌드 반영**: Zustand나 Jotai와 같은 새로운 라이브러리들도 고려해볼 만합니다[3](https://insight.infograb.net/blog/2024/11/20/client-state/).

프로젝트의 이러한 특성들을 종합적으로 고려하여 가장 적합한 상태관리 패러다임과 라이브러리를 선택하는 것이 중요합니다. 또한, 프로젝트가 진행됨에 따라 요구사항이 변경될 수 있으므로, 필요에 따라 유연하게 접근하는 것이 좋습니다.

### Citations:

1. [https://blog.soaple.io/entry/어떤-상태관리-라이브러리를-써야할까](https://blog.soaple.io/entry/%EC%96%B4%EB%96%A4-%EC%83%81%ED%83%9C%EA%B4%80%EB%A6%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EB%A5%BC-%EC%8D%A8%EC%95%BC%ED%95%A0%EA%B9%8C)
2. [https://careerly.co.kr/qnas/1282](https://careerly.co.kr/qnas/1282)
3. [https://insight.infograb.net/blog/2024/11/20/client-state/](https://insight.infograb.net/blog/2024/11/20/client-state/)
4. [https://wormwlrm.github.io/2024/03/18/UI-Tools-History.html](https://wormwlrm.github.io/2024/03/18/UI-Tools-History.html)
5. [https://velog.io/@hozzijeong/프로젝트-라이브러리-선택](https://velog.io/@hozzijeong/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%84%A0%ED%83%9D)
6. [https://thisisdevelop.com/entry/frontendframework](https://thisisdevelop.com/entry/frontendframework)
7. [https://bandal.dev/React/state-management](https://bandal.dev/React/state-management)
8. [https://f-lab.kr/insight/choosing-frontend-frameworks](https://f-lab.kr/insight/choosing-frontend-frameworks)
9. [https://patrick-f.tistory.com/62](https://patrick-f.tistory.com/62)

---

Perplexity로부터의 답변: [pplx.ai/share](https://www.perplexity.ai/search/pplx.ai/share)

### 추천하는 조합

## **Zustand + React Query**

1. Zustand: 클라이언트 상태 관리
    - 간단한 API와 작은 번들 사이즈로 빠른 학습 곡선
    - 높은 성능과 유연성 제공
    - Redux에 비해 보일러플레이트 코드가 적음[3](https://insight.infograb.net/blog/2024/11/20/client-state/)[6](https://patrick-f.tistory.com/62)
2. React Query: 서버 상태 관리
    - 비동기 데이터 fetching, 캐싱, 동기화에 특화
    - 서버 상태와 클라이언트 상태를 명확히 구분

### 그럼에도 Redux를 공부해야 하는 이유가 있다면?

- 개발자 커뮤니티도 활성화 되어 있고, 대규모 프로젝트에 적합한 구조에 따라 많은 기업에서 활용하고 있음 현재 채용공고 상 Redux 경험을 요구하는 경우가 꽤 있음 아니면 그 외 상태 관리 라이브러리 경험으로 퉁쳐서 요구하기도 함
- 근간이 되는 라이브러리 이기 때문에 공부를 통해 이 후 등장하는 상태관리 라이브러리와의 비교, 장단점을 알 수 있는데 도움이 됨

---

Perplexity로부터의 답변: [pplx.ai/share](https://www.perplexity.ai/search/pplx.ai/share)