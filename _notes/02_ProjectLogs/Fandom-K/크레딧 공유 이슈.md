
**의도)** DonationModal.jsx에서 보유 크레딧이 부족하면 충전하러가기 버튼을 띄우고 그 버튼을 누르면 ChargeModal이 나오게 한다.

**시도)** 모달들을 Routes 안에서 렌더링하고 버튼을 누르면 useNavigate로 이동한다.  
=> 모달을 열기위한 isOpenP props가 전달이 안됨...  
**원인)** => React Router는 Route가 바뀔때마다 element를 새로 렌더링한다. 그래서 isOpenP 값이 유지되지 않고 다시 초기화됨

**해결)** 버튼에 onClick으로 setOpenOtherModal을 true로 바꿔준다 ChargeModal을 추가해주고 isOpenP 프롭에 openOtherModal을 넣어준다

---

**문제2 )** 충전하러가기 버튼을 클릭하면 ChargeModal이 잘 뜨긴하지만 ChargeModal이 닫히면 DonationModal도 함께 닫힌다  
사용자가 다시 후원하기 버튼을 클릭하면 되지만...불편할거같다...ChargeModal에서 충전만 하고 DonationModal은 그대로 두면 좋겠다!

**원인 )** 부모 컴포넌트에서 isOpenP를 관리하기 때문에..?  
**해결 )** DonationModal을 호출하는 부분에 !openOtherModal 조건을 넣어주면 ChargeModal이 닫혀도 DonationModal이 유지!  
👏👏👏👏👏👏

---

🐞 버그 설명  
후원하거나 투표하면 크레딧이 줄긴하는데 다시 충전하기로 돌아가서 충전버튼을 누르면 감소하기 전의 크레딧이 올라간다...

`DonationModal.jsx`

```
const [totalDonationCredit, setTotalDonationCredit] = useState(
    localStorage.getItem("credit")
  );

const handleDonationButtonClick = () => {
    if (parseInt(totalDonationCredit) > inputCredit) {
      const result = parseInt(totalDonationCredit) - inputCredit;
      localStorage.setItem("credit", result.toString());
      setTotalDonationCredit(result);
    }
  };

<button onClick={handleDonationButtonClick}>확인</button>
```

`ChargeModal.jsx`

```
const [chargeCredit, setChargeCredit] = useState(
    localStorage.getItem("credit")
  );

const handleButtonClick = () => {
    const result = (parseInt(chargeCredit) || 0) + selectCredit;
    localStorage.setItem("credit", result.toString());
    setChargeCredit(result);
  };

<button onClick={handleButtonClick}>확인</button>
```

`VoteModal.jsx`

```
const [totalCredit, setTotalCredit] = useState(
    localStorage.getItem("credit")
  );

const handleVoteButton = () => {
    if (parseInt(totalCredit) > 1000) {
      const result = parseInt(totalCredit) - 1000;
      localStorage.setItem("credit", result.toString());
      setTotalCredit(result);
      setAlert(false);
    } else {
      setAlert(true);
    }
  };

<button onClick={handleVoteButton}>ddsfdfsdf</button>
```

🌀 **문제상황** 🌀  
각 모달에 localStorage가 영향을 주면서 값이 바뀌어야 하는데 각 모달에 따로 적용  
=> 예시) 1. ChargeModal에서 10000 크레딧 충전  
2. VoteModal ( or DonationModal) 에서 3000 크레딧 소모  
3. VoteModal을 나가기 전까지는 크레딧이 정상적으로 감소  
4. 다시 ChargeModal을 들어가면 들어간 직후에는 소모된 크레딧으로 보이다가, 크레딧 충전하기 버튼을 누르면 감소하기 전 크레딧에 추가됨 ( 7000크레딧에서 1000크레딧 충전시 8000크레딧이 되는게 아닌 11000크레딧이 됨.....)

---

**원인**  
크레딧을 각 모달에서 useState(localStorage.getItem("credit")으로 관리하고 있다.  
useState로 관리하는 상태는 컴포넌트가 마운트 될때 설정된다.  
따라서 이후 다른 모달에서 크레딧 값을 변경해도 현재 열린 모달의 state는 변하지 않는다....  
예를들어 chargeModal에서 충전한 credit이 1000이고 donationModal에서 쓴 credit이 100이면  
900이 chargeModal의 credit에 반영될거같지만 사실은 이미 1000이 설정되어있어 donationModal은 chargeModal의 state에 관여하지 않기 떄문에 chargeModal의 credit은 여전히 1000이었던것이다..

---

**시도**

커스텀 훅을 만들어서 useEffect에  
storage 이벤트를 addEventListener로 등록하고 credit 값을 불러온다..

=> **문제** storag이벤트는 같은 탭에서는 자동으로 실행되지 않는다..list 페이지에서 위에 모달을 띄우는것이기 때문에 잘 동작하지 않음

**해결**

커스텀 이벤트를 만들어서 해결한다

```
useEffect(() => {
    const updateCredit = () => {
      setLocalCredit(parseInt(localStorage.getItem("credit")) || 0);
    };
    // 커스텀 이벤트 리스너,
    // 컴포넌트 마운트시 리스너가 등록되어 이후 creditUpdate 이벤트가 발생할 때마다 상태가 업데이트 됨
    window.addEventListener("creditUpdate", updateCredit);
    //클린업
    return () => window.removeEventListener("creditUpdate", updateCredit);
  }, []);

  const setNewCredit = (newCredit) => {
    localStorage.setItem("credit", newCredit.toString());
    setLocalCredit(newCredit);
    window.dispatchEvent(new Event("creditUpdate"));
  };
```