
`const sliderRef = useRef<HTMLDivElement>(null);` 

- 슬라이더 **DOM 요소를 직접 조작**하려고 만듦.
    
- `useRef`는 **렌더링 없이** DOM에 접근 가능.
    
- **슬라이더 div**에 이 `ref`를 달아줌.
    

---


`const intervalRef = useRef<NodeJS.Timeout | null>(null);`

- **setInterval** 타이머 ID 저장용.
    
- 이거 없으면 타이머를 **멈추거나 정리** 못 함.
    
- `null`로 시작하고, 나중에 `setInterval`이 실행되면 값이 들어감.
    

---


`const [isHover, setIsHover] = useState(false);`

- **hover 상태**를 관리하는 state.
    
- `true` → 마우스 올라와 있음.
    
- `false` → 마우스 안 올라와 있음.
    
- 이거에 따라 **자동 스크롤 멈출지**, **버튼 보일지** 결정.
    

---

`const { openModal } = useModalStore();`

- **전역 상태 관리(store)**.
    
- `useModalStore`에서 **모달 열기 함수**를 가져옴.
    
- 이미지 클릭했을 때 모달 열 때 사용.


---

`useEffect(() => {   const slider = sliderRef.current;   if (!slider) return;`

- 컴포넌트 **렌더링되거나** `isHover`가 바뀔 때 실행.
    
- `sliderRef`가 아직 안 붙은 상태(null)면 그냥 리턴.
    

---


`if (isHover) {   if (intervalRef.current) {     clearInterval(intervalRef.current);     intervalRef.current = null;   }   return; }`

- **hover 중이면 자동 스크롤 멈춰야** 해.
    
- 이미 돌아가고 있던 `setInterval`을 `clearInterval`로 멈춤.
    
- 그리고 `intervalRef.current`를 `null`로 초기화.
    
- hover 중이면 **더 이상 스크롤 돌리면 안 돼서 return**.
    

---

`intervalRef.current = setInterval(() => {   if (!slider) return;`

- hover 중이 아니면 **5초마다 자동 스크롤** 시작.
    
- `intervalRef`에 타이머 ID 저장.
    
- **slider가 존재할 때만 실행**.
    

---


`const maxScrollLeft = slider.scrollWidth - slider.offsetWidth; const isAtEnd = Math.ceil(slider.scrollLeft) >= maxScrollLeft;`

- **스크롤할 수 있는 최대 거리** 계산.
    
    - `scrollWidth`: 전체 가로 길이.
        
    - `offsetWidth`: 보이는 창(viewport) 너비.
        
    - 전체 길이 - 보이는 길이 = 스크롤 가능한 최대 거리.
        
- **현재 스크롤 위치가 끝에 다다랐는지** 체크.
    

---

`if (isAtEnd) {   slider.scrollTo({ left: 0, behavior: 'smooth' }); } else {   slider.scrollBy({ left: slider.offsetWidth, behavior: 'smooth' }); }`

- **끝까지 갔으면**: 맨 처음으로 **부드럽게 이동**.
    
- **아직 덜 갔으면**: 다음 이미지 보이도록 **한 화면만큼 부드럽게 이동**.
    

---

`return () => {   if (intervalRef.current) clearInterval(intervalRef.current); };`

- **컴포넌트가 언마운트되거나**,
    
- **`isHover`가 바뀔 때** 이전 타이머를 정리(clean-up).
    
- **타이머 중복 방지**.
    

---

`const scrollLeft = () => {   if (sliderRef.current) {     sliderRef.current.scrollBy({ left: -sliderRef.current.offsetWidth, behavior: 'smooth' });   } };`

- **왼쪽 버튼** 누르면:
    
    - **한 화면 크기만큼 왼쪽**으로 부드럽게 스크롤.
        

---


`const scrollRight = () => {   if (sliderRef.current) {     sliderRef.current.scrollBy({ left: sliderRef.current.offsetWidth, behavior: 'smooth' });   } };`

- **오른쪽 버튼** 누르면:
    
    - **한 화면 크기만큼 오른쪽**으로 부드럽게 스크롤.
        

---

|코드|역할|
|---|---|
|`sliderRef`|슬라이더 DOM 접근|
|`intervalRef`|자동 스크롤 타이머 ID 저장|
|`isHover`|hover 상태 관리|
|`openModal`|모달 열기 함수 가져오기|
|`useEffect`|hover에 따라 스크롤 시작/멈춤|
|`setInterval`|5초마다 스크롤|
|`clearInterval`|스크롤 멈춤/정리|
|`scrollLeft`|왼쪽으로 한 화면 스크롤|
|`scrollRight`|오른쪽으로 한 화면 스크롤|

---


- hover 아니면 **5초마다 부드럽게 스크롤**
    
- hover 하면 **자동 스크롤 멈춤**
    
- 버튼 누르면 **수동 스크롤 가능**
    
- 클릭하면 **모달 열기**
    

---

1. `sliderRef가 아직 안 붙은 상태(null)면 그냥 리턴.`


`const slider = sliderRef.current; if (!slider) return;`

- `useRef`는 처음에 `null`이야.
    
- 이 `sliderRef`를 `<div ref={sliderRef}>`에 연결할 거야.
    
- 그런데 **처음 렌더링될 때**는 아직 DOM이 없어서 `null`.
    
- **null인 상태에서 뭔가 조작하려고 하면 에러나니까** 먼저 `null`이면 그냥 `return` 해버려.
    

> **즉:**  
> `sliderRef`가 아직 **실제로 div에 안 붙었으면 아무것도 하지 마라.**

---
2. `intervalRef.current`


`const intervalRef = useRef<NodeJS.Timeout | null>(null);`

- `intervalRef`는 **setInterval** 타이머 ID 저장할 변수야.
    
- `useRef`는 **렌더링 없이 값을 기억**할 수 있어.
    
- 왜 `useState` 안 쓰고 `useRef` 쓰냐?
    
    - 타이머 ID를 저장할 때 **렌더링이 필요 없으니까** `useRef` 씀.
        

> **타이머 번호를 기억해두는 비밀 메모장**  
> (`intervalRef.current = 1234` 이런 식으로 setInterval ID가 들어감)

---
3. `sliderRef.current`

`const sliderRef = useRef<HTMLDivElement>(null); const slider = sliderRef.current;`

- **이건 div DOM 자체**야.
    
- 네 코드에서는 슬라이더를 감싸고 있는 `<div>`를 직접 조작하려고 해.
    
- `sliderRef.current` → 진짜 그 **DOM 요소(div)**를 가리켜.
    

> **쉽게 말하면:**  
> **슬라이더 div**에 직접 가서 "스크롤 좀 해!" 이렇게 명령하는 거야.

---
4. `scrollTo`, `scrollBy`

- **둘 다 div의 스크롤 위치를 바꾸는 함수야.**
    

`scrollTo`

`slider.scrollTo({ left: 0, behavior: 'smooth' });`

- **슬라이더의 스크롤 위치를 0으로 이동**시킴.
    
- **`left: 0`** → 왼쪽 맨 처음으로 이동
    
- **`behavior: 'smooth'`** → 부드럽게 스르륵 이동
    

> **쉽게 말하면:**  
> "슬라이더야, 스크롤 맨 처음으로 **스르륵 이동**해!"

---

`scrollBy`

`slider.scrollBy({ left: slider.offsetWidth, behavior: 'smooth' });`

- **현재 위치에서 offsetWidth만큼 오른쪽으로 이동.**
    
- offsetWidth = 한 화면 가로 길이.
    
- 그러니까 **한 화면(이미지 1장)** 만큼 오른쪽으로 스크롤.
    
- 부드럽게(`behavior: 'smooth'`) 이동.
    

> **쉽게 말하면:**  
> "지금 있는 자리에서 **한 장 옆으로** 스르륵 이동해!"

---
5. `behavior: 'smooth'`

- 스크롤 할 때 그냥 **뚝뚝 이동하면 UX 별로**야.
    
- 그래서 스크롤할 때 **부드럽게 움직이게 해주는 옵션**.
    

|옵션 값|의미|
|---|---|
|`'auto'`|뚝뚝 끊기는 기본 스크롤|
|`'smooth'`|**부드럽게** 스크롤|

> **쉽게 말하면:**  
> "사용자한테 스르륵 부드러운 애니메이션 보여줘!"

---

 **한 번에 비유

- **sliderRef**: 슬라이더 `div` 직접 가리키는 포인터.
    
- **intervalRef**: 5초마다 자동으로 움직이는 타이머 시계번호 저장.
    
- **scrollTo**: "슬라이더야, **처음**으로 가자!"
    
- **scrollBy**: "슬라이더야, **오른쪽으로 한 칸** 가자!"
    
- **behavior: 'smooth'**: "스르륵~ 부드럽게 움직여!"
    

---

ref는 필요한곳에서만 사용하는게 좋다
state와 css로 슬라이드 구현해보기
time같은 경우에는 어쩔수없지만 

모바일을 보통 마우스가 없기때문에 호버처리를 안한다
(디자이너가 요구한 경우에는 어쩔수없지만)